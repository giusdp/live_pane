{
  "version": 3,
  "sources": ["../../assets/js/live_pane/utils.ts", "../../assets/js/live_pane/store.ts", "../../assets/js/live_pane/core.ts", "../../assets/js/live_pane/compare.ts", "../../assets/js/live_pane/resize.ts", "../../assets/js/live_pane/hooks/group.ts", "../../assets/js/live_pane/style.ts", "../../assets/js/live_pane/adjust-layout.ts", "../../assets/js/live_pane/hooks/pane.ts", "../../assets/js/live_pane/chain.ts", "../../assets/js/live_pane/event.ts", "../../assets/js/live_pane/hooks/resizer.ts", "../../assets/js/live_pane/live_pane.ts"],
  "sourcesContent": ["import type { ResizeEvent } from './core';\n\nexport function noop() {}\n\nexport function assert(\n  expectedCondition: any,\n  message: string = 'Assertion failed!'\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nexport function safe_not_equal(a: any, b: any) {\n  return a != a\n    ? b == b\n    : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nexport function subscribe(store: any, ...callbacks: ((_: any) => any)[]) {\n  if (store == null) {\n    return noop;\n  }\n  const unsub = store.subscribe(...callbacks);\n  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\nexport function isHTMLElement(element: unknown): element is HTMLElement {\n  return element instanceof HTMLElement;\n}\n\nexport function isMouseEvent(event: ResizeEvent): event is MouseEvent {\n  return event.type.startsWith('mouse');\n}\n\nexport function isTouchEvent(event: ResizeEvent): event is TouchEvent {\n  return event.type.startsWith('touch');\n}\n\nexport function isKeyDown(event: ResizeEvent): event is KeyboardEvent {\n  return event.type === 'keydown';\n}\n", "import { safe_not_equal } from './utils';\n\n/** Callback to inform of a value updates. */\nexport type Subscriber<T> = (value: T) => void;\n\n/** Unsubscribes from value updates. */\nexport type Unsubscriber = () => void;\n\n/** Writable interface for both updating and subscribing. */\nexport interface Writable<T> {\n  set(this: void, value: T): void;\n\n  get(this: void): T;\n\n  update(this: void, updater: (value: T) => T): void;\n\n  subscribe(this: void, run: Subscriber<T>): Unsubscriber;\n}\n\nexport function writable<T>(value: T): Writable<T> {\n  const subscribers: Set<Subscriber<T>> = new Set();\n\n  function set(new_value: T): void {\n    if (safe_not_equal(value, new_value)) {\n      value = new_value;\n      for (const subscriber of subscribers) {\n        subscriber(new_value);\n      }\n    }\n  }\n\n  function get(): T {\n    return value as T;\n  }\n\n  function update(fn: (value: T) => T): void {\n    set(fn(value));\n  }\n\n  function subscribe(subscriber: Subscriber<T>): Unsubscriber {\n    subscribers.add(subscriber);\n    subscriber(value);\n\n    return () => {\n      subscribers.delete(subscriber);\n    };\n  }\n\n  return { set, get, update, subscribe };\n}\n", "import { Unsubscriber, writable, type Writable } from './store';\n\nexport const PRECISION = 10;\n\nexport const paneGroupInstances = new Map<GroupId, PaneGroupData>();\nexport const paneInstances = new Map<PaneId, PaneManagementData>();\nexport const resizerInstances = new Map<ResizerId, ResizerData>();\nexport const dragState: Writable<DragState | null> = writable(null);\n\nexport type PaneManagementData = {\n  groupId: string;\n  unsubs: Unsubscriber[];\n};\nexport type ResizerData = {\n  disabled: Writable<boolean>;\n  resizeHandlerCallback: ResizeHandler | null;\n  isDragging: Writable<boolean>;\n  unsubs: Unsubscriber[];\n  isFocused: Writable<boolean>;\n};\n\nexport type GroupId = string;\nexport type PaneId = string;\nexport type ResizerId = string;\n\nexport type PaneGroupData = {\n  paneDataArray: Writable<PaneData[]>;\n  paneDataArrayChanged: Writable<boolean>;\n  direction: Writable<Direction>;\n  layout: Writable<number[]>;\n  prevDelta: Writable<number>;\n  keyboardResizeBy: number | null;\n\n  onLayoutChange?: (layout: number[]) => void;\n\n  paneIdToLastNotifiedSizeMap: Record<string, number>;\n  paneSizeBeforeCollapseMap: Map<string, number>;\n\n  unsubFromPaneDataChange: Unsubscriber;\n};\n\nexport type Direction = 'horizontal' | 'vertical';\n\nexport type DragState = {\n  dragHandleId: string;\n  dragHandleRect: DOMRect;\n  initialCursorPosition: number;\n  initialLayout: number[];\n};\n\nexport type PaneConstraints = {\n  collapsedSize: number;\n  collapsible: boolean;\n  defaultSize?: number;\n  maxSize: number;\n  minSize: number;\n};\n\nexport type PaneData = {\n  id: string;\n  order: number;\n  constraints: PaneConstraints;\n};\n\nexport type ResizeEvent = KeyboardEvent | MouseEvent | TouchEvent;\nexport type ResizeHandler = (event: ResizeEvent) => void;\n\nexport type PaneResizeHandleOnDragging = (isDragging: boolean) => void;\n\nexport type PaneOnCollapse = () => void;\nexport type PaneOnExpand = () => void;\nexport type PaneOnResize = (size: number, prevSize: number | undefined) => void;\n\nexport type PaneGroupOnLayout = (layout: number[]) => void;\n\nexport type CollapseEvent = {\n  paneId: string;\n};\n", "import { PRECISION } from './core';\n\n/**\n * Compares two numbers for equality with a given fractional precision.\n */\nexport function areNumbersAlmostEqual(\n  actual: number,\n  expected: number,\n  fractionDigits: number = PRECISION\n): boolean {\n  return compareNumbersWithTolerance(actual, expected, fractionDigits) === 0;\n}\n\n/**\n * Compares two numbers with a given tolerance.\n *\n * @returns `-1` if `actual` is less than `expected`, `0` if they are equal,\n * and `1` if `actual` is greater than `expected`.\n */\nexport function compareNumbersWithTolerance(\n  actual: number,\n  expected: number,\n  fractionDigits: number = PRECISION\n): number {\n  const roundedActual = roundTo(actual, fractionDigits);\n  const roundedExpected = roundTo(expected, fractionDigits);\n\n  return Math.sign(roundedActual - roundedExpected);\n}\n\n/**\n * Compares two arrays for equality.\n */\nexport function areArraysEqual<T extends Array<unknown>>(\n  arrA: T,\n  arrB: T\n): boolean {\n  if (arrA.length !== arrB.length) return false;\n\n  for (let index = 0; index < arrA.length; index++) {\n    if (arrA[index] !== arrB[index]) return false;\n  }\n\n  return true;\n}\n\n/**\n * Rounds a number to a given number of decimal places.\n */\nfunction roundTo(value: number, decimals: number): number {\n  return parseFloat(value.toFixed(decimals));\n}\n", "import { PRECISION } from './core';\nimport type { PaneConstraints } from './core';\nimport { assert } from './utils';\nimport { compareNumbersWithTolerance } from './compare';\n\ntype ResizePaneArgs = {\n  paneConstraintsArray: PaneConstraints[];\n  paneIndex: number;\n  size: number;\n};\n/**\n * Resizes a pane based on its constraints.\n */\nexport function resizePane({\n  paneConstraintsArray: constraints,\n  paneIndex,\n  size\n}: ResizePaneArgs): number {\n  assert(\n    constraints[paneIndex] != null,\n    'Pane constraints should not be null.'\n  );\n\n  const { collapsedSize, collapsible, maxSize, minSize } =\n    constraints[paneIndex];\n\n  let newSize = size;\n\n  if (compareNumbersWithTolerance(newSize, minSize) < 0) {\n    newSize = getAdjustedSizeForCollapsible(\n      newSize,\n      collapsible,\n      collapsedSize,\n      minSize\n    );\n  }\n\n  newSize = Math.min(maxSize, newSize);\n  return parseFloat(newSize.toFixed(PRECISION));\n}\n\n/**\n * Adjusts the size of a pane based on its collapsible state.\n *\n * If the pane is collapsible, the size will be snapped to the collapsed size\n * or the minimum size based on the halfway point.\n */\nfunction getAdjustedSizeForCollapsible(\n  size: number,\n  collapsible: boolean,\n  collapsedSize: number,\n  minSize: number\n): number {\n  if (!collapsible) return minSize;\n\n  // Snap collapsible panes closed or open based on the halfway point.\n  const halfwayPoint = (collapsedSize + minSize) / 2;\n  return compareNumbersWithTolerance(size, halfwayPoint) < 0\n    ? collapsedSize\n    : minSize;\n}\n", "import { Hook } from 'phoenix_live_view';\nimport { Writable, writable } from '../store';\nimport type {\n  Direction,\n  PaneData,\n  PaneGroupData,\n  PaneConstraints\n} from '../core';\nimport { paneGroupInstances } from '../core';\n\nimport { areArraysEqual, areNumbersAlmostEqual } from '../compare';\nimport { assert } from '../utils';\nimport { resizePane } from '../resize';\n\nexport function createGroupHook() {\n  let groupHook: Hook = {\n    mounted() {\n      if (!this.el.id) {\n        throw Error('Pane Group must have an id.');\n      }\n      if (paneGroupInstances.has(this.el.id)) {\n        throw Error(`Pane Group with id \"${this.el.id}\" already exists.`);\n      }\n\n      const dir = this.el.getAttribute('data-pane-direction') || 'horizontal';\n      const keyboardResizeByAttr = this.el.getAttribute('keyboard-resize-by');\n      const keyboardResizeBy: number | null = keyboardResizeByAttr\n        ? Number(keyboardResizeByAttr)\n        : null;\n\n      const paneDataArray = writable<PaneData[]>([]);\n      const paneDataArrayChanged = writable(false);\n\n      const direction = writable<Direction>(dir as Direction);\n      const layout = writable<number[]>([]);\n      const prevDelta = writable<number>(0);\n      const dragHandleId = '';\n\n      const paneIdToLastNotifiedSizeMap: Record<string, number> = {};\n      const paneSizeBeforeCollapseMap = new Map<string, number>();\n\n      const unsubFromPaneDataChange = updateLayoutOnPaneDataChange(\n        layout,\n        paneDataArray,\n        paneDataArrayChanged\n      );\n      const groupData: PaneGroupData = {\n        paneDataArray,\n        paneDataArrayChanged,\n        direction,\n        dragHandleId,\n        layout,\n        prevDelta,\n        keyboardResizeBy,\n        paneIdToLastNotifiedSizeMap,\n        paneSizeBeforeCollapseMap,\n        unsubFromPaneDataChange\n      };\n\n      paneGroupInstances.set(this.el.id, groupData);\n    },\n\n    destroyed() {\n      paneGroupInstances.get(this.el.id)?.unsubFromPaneDataChange();\n      paneGroupInstances.delete(this.el.id);\n    }\n  };\n\n  return groupHook;\n}\n\nfunction updateLayoutOnPaneDataChange(\n  layout: Writable<number[]>,\n  paneDataArray: Writable<PaneData[]>,\n  paneDataArrayChanged: Writable<boolean>\n) {\n  return paneDataArrayChanged.subscribe(changed => {\n    if (!changed) return;\n    paneDataArrayChanged.set(false);\n\n    const $prevLayout = layout.get();\n    const $paneDataArray = paneDataArray.get();\n\n    let unsafeLayout: number[] | null = null;\n\n    if (unsafeLayout == null) {\n      unsafeLayout = getUnsafeDefaultLayout({\n        paneDataArray: $paneDataArray\n      });\n    }\n\n    // Validate even saved layouts in case something has changed since last render\n    const nextLayout = validatePaneGroupLayout({\n      layout: unsafeLayout,\n      paneConstraintsArray: $paneDataArray.map(paneData => paneData.constraints)\n    });\n\n    if (areArraysEqual($prevLayout, nextLayout)) return;\n\n    layout.set(nextLayout);\n  });\n}\n\nfunction getUnsafeDefaultLayout({\n  paneDataArray\n}: { paneDataArray: PaneData[] }): number[] {\n  const layout = Array<number>(paneDataArray.length);\n\n  const paneConstraintsArray = paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  let numPanesWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < paneDataArray.length; index++) {\n    const paneConstraints = paneConstraintsArray[index];\n    assert(paneConstraints);\n    const { defaultSize } = paneConstraints;\n\n    if (defaultSize != null) {\n      numPanesWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panes without default sizes\n  for (let index = 0; index < paneDataArray.length; index++) {\n    const paneConstraints = paneConstraintsArray[index];\n    assert(paneConstraints);\n    const { defaultSize } = paneConstraints;\n\n    if (defaultSize != null) {\n      continue;\n    }\n\n    const numRemainingPanes = paneDataArray.length - numPanesWithSizes;\n    const size = remainingSize / numRemainingPanes;\n\n    numPanesWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n\n  return layout;\n}\n\n// All units must be in percentages\nfunction validatePaneGroupLayout({\n  layout: prevLayout,\n  paneConstraintsArray\n}: {\n  layout: number[];\n  paneConstraintsArray: PaneConstraints[];\n}): number[] {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce(\n    (accumulated, current) => accumulated + current,\n    0\n  );\n\n  // Validate layout expectations\n  if (nextLayout.length !== paneConstraintsArray.length) {\n    throw Error(\n      `Invalid ${paneConstraintsArray.length} pane layout: ${nextLayout\n        .map(size => `${size}%`)\n        .join(', ')}`\n    );\n  } else if (!areNumbersAlmostEqual(nextLayoutTotalSize, 100)) {\n    for (let index = 0; index < paneConstraintsArray.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null);\n      const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each pane's constraints\n  for (let index = 0; index < paneConstraintsArray.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null);\n\n    const safeSize = resizePane({\n      paneConstraintsArray,\n      paneIndex: index,\n      size: unsafeSize\n    });\n\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any pane(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!areNumbersAlmostEqual(remainingSize, 0)) {\n    for (let index = 0; index < paneConstraintsArray.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePane({\n        paneConstraintsArray,\n        paneIndex: index,\n        size: unsafeSize\n      });\n\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (areNumbersAlmostEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n\n  return nextLayout;\n}\n", "import type { DragState, PaneData } from './core';\n\n/**\n * A utility function that converts a style object to a string,\n * which can be used as the value of the `style` attribute for\n * an element.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style: StyleObject): string {\n  return Object.keys(style).reduce((str, key) => {\n    if (style[key] === undefined) return str;\n    return str + `${key}:${style[key]};`;\n  }, '');\n}\n\nexport type StyleObject = Record<string, number | string | undefined>;\n\ntype CursorState =\n  | 'horizontal'\n  | 'horizontal-max'\n  | 'horizontal-min'\n  | 'vertical'\n  | 'vertical-max'\n  | 'vertical-min';\n\n/* Global cursor state */\nlet currentState: CursorState | null = null;\n\n/* Global cursor element */\nlet element: HTMLStyleElement | null = null;\n\n/**\n * Returns the cursor style for a given cursor state.\n */\nexport function getCursorStyle(state: CursorState): string {\n  switch (state) {\n    case 'horizontal':\n      return 'ew-resize';\n    case 'horizontal-max':\n      return 'w-resize';\n    case 'horizontal-min':\n      return 'e-resize';\n    case 'vertical':\n      return 'ns-resize';\n    case 'vertical-max':\n      return 'n-resize';\n    case 'vertical-min':\n      return 's-resize';\n  }\n}\n\n/**\n * Resets the global cursor style to the default.\n */\nexport function resetGlobalCursorStyle() {\n  if (element === null) return;\n\n  document.head.removeChild(element);\n\n  currentState = null;\n  element = null;\n}\n\n/**\n * Sets the global cursor style to the given state.\n */\nexport function setGlobalCursorStyle(state: CursorState) {\n  if (currentState === state) return;\n\n  currentState = state;\n\n  const style = getCursorStyle(state);\n\n  if (element === null) {\n    element = document.createElement('style');\n    document.head.appendChild(element);\n  }\n\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\n/**\n * Computes the flexbox style for a pane given its layout and drag state.\n */\nexport function computePaneFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  paneData,\n  paneIndex,\n  precision = 3\n}: {\n  defaultSize: number | undefined;\n  layout: number[];\n  dragState: DragState | null;\n  paneData: PaneData[];\n  paneIndex: number;\n  precision?: number;\n}): string {\n  const size = layout[paneIndex];\n\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panes have registered themselves)\n    // To support server rendering, fallback to default size\n    flexGrow = defaultSize ?? '1';\n  } else if (paneData.length === 1) {\n    //  Single pane group should always fill full width/height\n    flexGrow = '1';\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n\n  return styleToString({\n    'flex-basis': 0,\n    'flex-grow': flexGrow,\n    'flex-shrink': 1,\n    // Without this, pane sizes may be unintentionally overridden by their content\n    overflow: 'hidden',\n    // Disable pointer events inside of a pane during resize\n    // This avoid edge cases like nested iframes\n    'pointer-events': dragState !== null ? 'none' : undefined\n  });\n}\n", "import type { PaneConstraints } from './core';\nimport { assert } from './utils';\nimport { compareNumbersWithTolerance, areNumbersAlmostEqual } from './compare';\nimport { resizePane } from './resize';\n\ntype AdjustLayoutByDeltaArgs = {\n  delta: number;\n  layout: number[];\n  paneConstraintsArray: PaneConstraints[];\n  pivotIndices: number[];\n  trigger: 'imperative-api' | 'keyboard' | 'mouse-or-touch';\n};\n/**\n * Adjusts the layout of panes based on the delta of the resize handle.\n * All units must be in percentages; pixel values should be pre-converted.\n *\n * Credit: https://github.com/bvaughn/react-resizable-panels\n */\nexport function adjustLayoutByDelta({\n  delta,\n  layout: prevLayout,\n  paneConstraintsArray,\n  pivotIndices,\n  trigger\n}: AdjustLayoutByDeltaArgs): number[] {\n  if (areNumbersAlmostEqual(delta, 0)) return prevLayout;\n\n  const nextLayout = [...prevLayout];\n\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, 'Invalid first pivot index');\n  assert(secondPivotIndex != null, 'Invalid second pivot index');\n\n  let deltaApplied = 0;\n\n  // A resizing pane affects the panes before or after it.\n  //\n  // A negative delta means the pane(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panes may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the pane(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panes after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the pane from expanding at all.\n    if (trigger === 'keyboard') {\n      {\n        // Check if we should expand a collapsed pane\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n\n        if (paneConstraints.collapsible) {\n          const prevSize = prevLayout[index];\n          assert(prevSize != null);\n\n          const paneConstraints = paneConstraintsArray[index];\n          assert(paneConstraints);\n          const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n\n          if (areNumbersAlmostEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n\n            if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a pane at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { collapsible } = paneConstraints;\n\n        if (collapsible) {\n          const prevSize = prevLayout[index];\n          assert(prevSize != null);\n\n          const paneConstraints = paneConstraintsArray[index];\n          assert(paneConstraints);\n          const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n\n          if (areNumbersAlmostEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n\n            if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panes in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too\u2013\n    // as an expanding pane might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    while (true) {\n      const prevSize = prevLayout[index];\n      assert(prevSize != null);\n\n      const maxSafeSize = resizePane({\n        paneConstraintsArray,\n        paneIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n\n      maxAvailableDelta += delta;\n      index += increment;\n\n      if (index < 0 || index >= paneConstraintsArray.length) {\n        break;\n      }\n    }\n\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n\n  {\n    // Delta added to a pane needs to be subtracted from other panes (within the constraints that those panes allow).\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < paneConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n\n      const prevSize = prevLayout[index];\n      assert(prevSize != null);\n\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePane({\n        paneConstraintsArray,\n        paneIndex: index,\n        size: unsafeSize\n      });\n\n      if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n\n        nextLayout[index] = safeSize;\n\n        if (\n          deltaApplied\n            .toPrecision(3)\n            .localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n              numeric: true\n            }) >= 0\n        ) {\n          break;\n        }\n      }\n\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panes, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a pane's boundaries\n  if (areNumbersAlmostEqual(deltaApplied, 0)) {\n    return prevLayout;\n  }\n\n  {\n    // Now distribute the applied delta to the panes in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n\n    const prevSize = prevLayout[pivotIndex];\n    assert(prevSize != null);\n\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePane({\n      paneConstraintsArray,\n      paneIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot pane before, but only by the amount that surrounding panes were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one pane caused another one to change collapsed state\n    if (!areNumbersAlmostEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < paneConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null);\n\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePane({\n          paneConstraintsArray,\n          paneIndex: index,\n          size: unsafeSize\n        });\n\n        if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n\n        if (areNumbersAlmostEqual(deltaRemaining, 0)) break;\n\n        delta > 0 ? index-- : index++;\n      }\n    }\n  }\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n\n  if (!areNumbersAlmostEqual(totalSize, 100)) return prevLayout;\n\n  return nextLayout;\n}\n", "import { Hook } from 'phoenix_live_view';\nimport {\n  CollapseEvent,\n  PaneData,\n  PaneGroupData,\n  PaneId,\n  paneInstances\n} from '../core';\nimport { Writable } from '../store';\nimport { dragState, paneGroupInstances } from '../core';\nimport { computePaneFlexBoxStyle } from '../style';\nimport { assert } from '../utils';\nimport { adjustLayoutByDelta } from '../adjust-layout';\nimport { areArraysEqual } from '../compare';\n\nexport function createPaneHook() {\n  let paneHook: Hook = {\n    mounted() {\n      const groupId = this.el.getAttribute('data-pane-group-id');\n      if (!groupId) {\n        throw Error('data-pane-group-id must exist for pane components!');\n      }\n      const paneId = this.el.id;\n      if (!paneId) {\n        throw Error('Id must exist for pane components!');\n      }\n      const orderAttr = this.el.getAttribute('data-pane-order');\n      const order = orderAttr ? Number(orderAttr) : 0;\n\n      const groupData = paneGroupInstances.get(groupId);\n      if (!groupData) {\n        throw Error('Group with id \"' + groupId + '\" does not exist.');\n      }\n\n      const collapsedSize = Number(this.el.getAttribute('collapsed-size')) || 0;\n      const collapsible = this.el.getAttribute('collapsible') === 'true';\n      const defaultSize =\n        Number(this.el.getAttribute('default-size')) || undefined;\n      const maxSize = Number(this.el.getAttribute('max-size')) || 100;\n      const minSize = Number(this.el.getAttribute('min-size')) || 0;\n\n      const paneData: PaneData = {\n        id: this.el.id,\n        order,\n        constraints: {\n          collapsedSize,\n          collapsible,\n          defaultSize,\n          maxSize,\n          minSize\n        }\n      };\n\n      registerPane(\n        paneData,\n        groupData.paneDataArray,\n        groupData.paneDataArrayChanged\n      );\n\n      const unsubs = setupReactivePaneStyle(\n        this.el,\n        groupData,\n        paneData,\n        defaultSize\n      );\n      paneInstances.set(paneId, { groupId, unsubs });\n\n      this.handleEvent('collapse', ({ pane_id }: { pane_id: string }) => {\n        if (paneId === pane_id) {\n          collapsePane(paneData, groupData);\n        }\n      });\n      this.handleEvent('expand', ({ pane_id }: { pane_id: string }) => {\n        if (paneId === pane_id) {\n          expandPane(paneData, groupData);\n        }\n      });\n    },\n\n    destroyed() {\n      const { groupId, unsubs } = paneInstances.get(this.el.id)!;\n\n      for (const unsub of unsubs) {\n        unsub();\n      }\n      const groupData = paneGroupInstances.get(groupId!);\n      unregisterPane(\n        this.el.id,\n        groupData!.paneDataArray,\n        groupData!.paneDataArrayChanged\n      );\n      paneInstances.delete(this.el.id);\n    }\n  };\n  return paneHook;\n}\n\nfunction registerPane(\n  paneData: PaneData,\n  paneDataArray: Writable<PaneData[]>,\n  paneDataArrayChanged: Writable<boolean>\n) {\n  paneDataArray.update(curr => {\n    const newArr = [...curr, paneData];\n    newArr.sort((paneA, paneB) => {\n      const orderA = paneA.order;\n      const orderB = paneB.order;\n\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    return newArr;\n  });\n  paneDataArrayChanged.set(true);\n}\n\nfunction unregisterPane(\n  paneId: PaneId,\n  paneDataArray: Writable<PaneData[]>,\n  paneDataArrayChanged: Writable<boolean>\n) {\n  const $paneDataArray = paneDataArray.get();\n  const index = findPaneDataIndex($paneDataArray, paneId);\n\n  if (index < 0) return;\n  paneDataArray.update(curr => {\n    curr.splice(index, 1);\n    paneDataArrayChanged.set(true);\n    return curr;\n  });\n}\n\nfunction findPaneDataIndex(paneDataArray: PaneData[], paneDataId: PaneId) {\n  return paneDataArray.findIndex(\n    prevPaneData => prevPaneData.id === paneDataId\n  );\n}\n\nfunction setupReactivePaneStyle(\n  el: HTMLElement,\n  groupData: PaneGroupData,\n  paneData: PaneData,\n  defaultSize: number | undefined\n) {\n  const getPaneStyle = () => {\n    const paneIndex = findPaneDataIndex(\n      groupData.paneDataArray.get(),\n      paneData.id\n    );\n    return computePaneFlexBoxStyle({\n      defaultSize,\n      dragState: dragState.get(),\n      layout: groupData.layout.get(),\n      paneData: groupData.paneDataArray.get(),\n      paneIndex\n    });\n  };\n\n  const arrUnsub = groupData.paneDataArray.subscribe(\n    _ => (el.style.cssText = getPaneStyle())\n  );\n  const layoutUnsub = groupData.layout.subscribe(_ => {\n    el.style.cssText = getPaneStyle();\n  });\n  const dragStateUnsub = dragState.subscribe(\n    _ => (el.style.cssText = getPaneStyle())\n  );\n\n  return [arrUnsub, layoutUnsub, dragStateUnsub];\n}\n\nfunction collapsePane(paneData: PaneData, groupData: PaneGroupData) {\n  const prevLayout = groupData.layout.get();\n  const paneDataArray = groupData.paneDataArray.get();\n\n  if (!paneData.constraints.collapsible) return;\n\n  const paneConstraintsArray = paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  const {\n    collapsedSize = 0,\n    paneSize,\n    pivotIndices\n  } = paneDataHelper(paneDataArray, paneData, prevLayout);\n\n  assert(paneSize != null);\n\n  if (paneSize === collapsedSize) return;\n\n  // Store the size before collapse, which is returned when `expand()` is called\n  groupData.paneSizeBeforeCollapseMap.set(paneData.id, paneSize);\n\n  const isLastPane =\n    findPaneDataIndex(paneDataArray, paneData.id) === paneDataArray.length - 1;\n  const delta = isLastPane\n    ? paneSize - collapsedSize\n    : collapsedSize - paneSize;\n\n  const nextLayout = adjustLayoutByDelta({\n    delta,\n    layout: prevLayout,\n    paneConstraintsArray,\n    pivotIndices,\n    trigger: 'imperative-api'\n  });\n\n  if (areArraysEqual(prevLayout, nextLayout)) {\n    return;\n  }\n\n  groupData.layout.set(nextLayout);\n  const onLayout = groupData.onLayoutChange;\n\n  if (onLayout) {\n    onLayout(nextLayout);\n  }\n}\n\nfunction expandPane(paneData: PaneData, groupData: PaneGroupData) {\n  const prevLayout = groupData.layout.get();\n  const paneDataArray = groupData.paneDataArray.get();\n\n  if (!paneData.constraints.collapsible) return;\n  const paneConstraintsArray = paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  const {\n    collapsedSize = 0,\n    paneSize,\n    minSize = 0,\n    pivotIndices\n  } = paneDataHelper(paneDataArray, paneData, prevLayout);\n\n  if (paneSize !== collapsedSize) return;\n  // Restore this pane to the size it was before it was collapsed, if possible.\n  const prevPaneSize = groupData.paneSizeBeforeCollapseMap.get(paneData.id);\n  const baseSize =\n    prevPaneSize != null && prevPaneSize >= minSize ? prevPaneSize : minSize;\n\n  const isLastPane =\n    findPaneDataIndex(paneDataArray, paneData.id) === paneDataArray.length - 1;\n\n  const delta = isLastPane ? paneSize - baseSize : baseSize - paneSize;\n\n  const nextLayout = adjustLayoutByDelta({\n    delta,\n    layout: prevLayout,\n    paneConstraintsArray,\n    pivotIndices,\n    trigger: 'imperative-api'\n  });\n\n  if (areArraysEqual(prevLayout, nextLayout)) return;\n\n  groupData.layout.set(nextLayout);\n\n  groupData.onLayoutChange?.(nextLayout);\n}\n\nfunction paneDataHelper(\n  paneDataArray: PaneData[],\n  paneData: PaneData,\n  layout: number[]\n) {\n  const paneConstraintsArray = paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  const paneIndex = findPaneDataIndex(paneDataArray, paneData.id);\n  const paneConstraints = paneConstraintsArray[paneIndex];\n\n  const isLastPane = paneIndex === paneDataArray.length - 1;\n  const pivotIndices = isLastPane\n    ? [paneIndex - 1, paneIndex]\n    : [paneIndex, paneIndex + 1];\n\n  const paneSize = layout[paneIndex];\n\n  return {\n    ...paneConstraints,\n    paneSize,\n    pivotIndices\n  };\n}\n", "/**\n * A callback function that takes an array of arguments of type `T` and returns `void`.\n * @template T The types of the arguments that the callback function takes.\n */\nexport type Callback<T extends unknown[] = unknown[]> = (...args: T) => void;\n\ntype NonEmptyArray<T> = [T, ...T[]];\n\n/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function chain<T extends unknown[]>(\n  ...callbacks: NonEmptyArray<Callback<T>>\n): (...args: T) => void {\n  return (...args) => {\n    for (const callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\n", "export type GeneralEventListener<E = Event> = (evt: E) => unknown;\n\nexport function addEventListener<E extends keyof HTMLElementEventMap>(\n  target: Window,\n  event: E,\n  handler: (this: Window, ev: HTMLElementEventMap[E]) => unknown,\n  options?: boolean | AddEventListenerOptions\n): VoidFunction;\n\nexport function addEventListener<E extends keyof HTMLElementEventMap>(\n  target: Document,\n  event: E,\n  handler: (this: Document, ev: HTMLElementEventMap[E]) => unknown,\n  options?: boolean | AddEventListenerOptions\n): VoidFunction;\n\nexport function addEventListener<E extends keyof HTMLElementEventMap>(\n  target: EventTarget,\n  event: E,\n  handler: GeneralEventListener<HTMLElementEventMap[E]>,\n  options?: boolean | AddEventListenerOptions\n): VoidFunction;\n\n/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(\n  target: Window | Document | EventTarget,\n  event: string | string[],\n  handler: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions\n) {\n  const events = Array.isArray(event) ? event : [event];\n\n  // Add the event listener to each specified event for the target element(s).\n  events.forEach(_event => target.addEventListener(_event, handler, options));\n\n  // Return a function that removes the event listener from the target element(s).\n  return () => {\n    events.forEach(_event =>\n      target.removeEventListener(_event, handler, options)\n    );\n  };\n}\n", "import { Hook } from 'phoenix_live_view';\nimport { dragState, paneGroupInstances, resizerInstances } from '../core';\nimport type {\n  Direction,\n  DragState,\n  GroupId,\n  PaneGroupData,\n  ResizeEvent,\n  ResizeHandler,\n  ResizerData,\n  ResizerId\n} from '../core';\nimport { chain } from '../chain';\nimport { addEventListener } from '../event';\nimport {\n  getCursorStyle,\n  resetGlobalCursorStyle,\n  setGlobalCursorStyle,\n  styleToString\n} from '../style';\nimport { Unsubscriber, writable, Writable } from '../store';\nimport { assert, isKeyDown, isMouseEvent, isTouchEvent } from '../utils';\nimport { areArraysEqual } from '../compare';\nimport { adjustLayoutByDelta } from '../adjust-layout';\n\nexport function createResizerHook() {\n  let resizerHook: Hook = {\n    mounted() {\n      // -- Retrieve data from group\n      let groupId = this.el.getAttribute('data-pane-group-id');\n      if (!groupId) {\n        throw Error('data-pane-group-id must exist for resizer components!');\n      }\n      let resizerId = this.el.getAttribute('id');\n      if (!resizerId) {\n        throw Error('Resizer id must exist for resizer components!');\n      }\n      const groupData = paneGroupInstances.get(groupId);\n      if (!groupData) {\n        throw Error(`Missing group \"${groupId} for resizer \"${resizerId}`);\n      }\n\n      // -- Register the resizer\n      const thisResizerData: ResizerData = {\n        disabled: writable(false),\n        isDragging: writable(false),\n        resizeHandlerCallback: null,\n        unsubs: [],\n        isFocused: writable(false)\n      };\n\n      resizerInstances.set(resizerId, thisResizerData);\n\n      // -- Prepare action params\n      thisResizerData.disabled.set(\n        this.el.getAttribute('data-pane-disabled') === 'true'\n      );\n\n      if (!thisResizerData.disabled.get()) {\n        const keyboardResizeBy = groupData.keyboardResizeBy;\n        thisResizerData.resizeHandlerCallback = (event: ResizeEvent) => {\n          const cursorPos = dragState.get()?.initialCursorPosition ?? null;\n          const initialLayout = dragState.get()?.initialLayout ?? null;\n          resizeHandler(\n            groupId,\n            resizerId,\n            groupData,\n            initialLayout,\n            cursorPos,\n            keyboardResizeBy,\n            event\n          );\n        };\n      }\n\n      const unsubEvents = setupResizeEvents(\n        resizerId,\n        this.el,\n        thisResizerData\n      );\n\n      thisResizerData.unsubs.push(unsubEvents);\n\n      // -- Set up the element\n      const style = styleToString({\n        cursor: getCursorStyle(groupData.direction.get()),\n        'touch-action': 'none',\n        'user-select': 'none',\n        '-webkit-user-select': 'none',\n        '-webkit-touch-callout': 'none'\n      });\n\n      this.el.style.cssText = style;\n\n      this.el.onblur = () => thisResizerData.isFocused.set(false);\n      this.el.onfocus = () => thisResizerData.isFocused.set(true);\n\n      this.el.onmousedown = e => {\n        e.preventDefault();\n        const nextDragState = startDragging(\n          groupData.direction,\n          groupData.layout,\n          resizerId,\n          e\n        );\n        dragState.set(nextDragState);\n        thisResizerData.isDragging.set(\n          dragState.get()?.dragHandleId === resizerId\n        );\n      };\n\n      this.el.onmouseup = () => {\n        dragState.set(null);\n        resetGlobalCursorStyle();\n        thisResizerData.isDragging.set(false);\n      };\n\n      this.el.ontouchcancel = () => {\n        dragState.set(null);\n        resetGlobalCursorStyle();\n        thisResizerData.isDragging.set(false);\n      };\n\n      this.el.ontouchend = () => {\n        dragState.set(null);\n        resetGlobalCursorStyle();\n        thisResizerData.isDragging.set(false);\n      };\n\n      this.el.ontouchstart = e => {\n        e.preventDefault();\n        const nextDragState = startDragging(\n          groupData.direction,\n          groupData.layout,\n          resizerId,\n          e\n        );\n        dragState.set(nextDragState);\n        thisResizerData.isDragging.set(\n          dragState.get()?.dragHandleId === resizerId\n        );\n      };\n\n      this.el.onkeydown = e => {\n        handleKeydown(\n          groupId,\n          resizerId,\n          thisResizerData.disabled.get(),\n          thisResizerData.resizeHandlerCallback,\n          e\n        );\n      };\n    },\n\n    destroyed() {\n      let resizerId = this.el.getAttribute('id');\n      for (const unsub of resizerInstances.get(resizerId!)?.unsubs ?? []) {\n        unsub();\n      }\n      resizerInstances.delete(resizerId!);\n    }\n  };\n\n  return resizerHook;\n}\n\nfunction setupResizeEvents(\n  resizerId: ResizerId,\n  node: HTMLElement,\n  params: ResizerData\n): Unsubscriber {\n  const { disabled, resizeHandlerCallback, isDragging } = params;\n\n  const onMove = (event: ResizeEvent) => {\n    if (\n      resizerId !== dragState.get()?.dragHandleId ||\n      disabled.get() ||\n      !isDragging.get() ||\n      resizeHandlerCallback === null\n    ) {\n      return;\n    }\n    resizeHandlerCallback(event);\n  };\n\n  const onMouseLeave = (event: ResizeEvent) => {\n    if (\n      resizerId !== dragState.get()?.dragHandleId ||\n      disabled.get() ||\n      !isDragging.get() ||\n      resizeHandlerCallback === null\n    ) {\n      return;\n    }\n    resizeHandlerCallback(event);\n  };\n\n  const stopDraggingAndBlur = () => {\n    if (resizerId !== dragState.get()?.dragHandleId) {\n      return;\n    }\n    node.blur();\n    isDragging.set(false);\n    dragState.set(null);\n    resetGlobalCursorStyle();\n  };\n\n  return chain(\n    addEventListener(document.body, 'contextmenu', stopDraggingAndBlur),\n    addEventListener(document.body, 'mousemove', onMove),\n    addEventListener(document.body, 'mouseleave', onMouseLeave),\n    addEventListener(window, 'mouseup', stopDraggingAndBlur),\n    addEventListener(document.body, 'touchmove', onMove, { passive: false }),\n    addEventListener(window, 'touchend', stopDraggingAndBlur)\n  );\n}\n\nfunction resizeHandler(\n  groupId: GroupId,\n  resizerId: ResizerId,\n  groupData: PaneGroupData,\n  initialLayout: number[] | null,\n  initialCursorPosition: number | null,\n  keyboardResizeBy: number | null,\n  event: ResizeEvent\n) {\n  event.preventDefault();\n\n  const direction = groupData.direction.get();\n  const $prevLayout = groupData.layout.get();\n  const $paneDataArray = groupData.paneDataArray.get();\n  const pivotIndices = getPivotIndices(groupId, resizerId);\n\n  let delta = getDeltaPercentage(\n    event,\n    resizerId,\n    direction,\n    initialCursorPosition,\n    keyboardResizeBy\n  );\n  if (delta === 0) return;\n\n  // support RTL\n  const isHorizontal = direction === 'horizontal';\n  if (document.dir === 'rtl' && isHorizontal) {\n    delta = -delta;\n  }\n\n  const paneConstraintsArray = $paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  const nextLayout = adjustLayoutByDelta({\n    delta,\n    layout: initialLayout ?? $prevLayout,\n    paneConstraintsArray,\n    pivotIndices,\n    trigger: isKeyDown(event) ? 'keyboard' : 'mouse-or-touch'\n  });\n\n  const layoutChanged = !areArraysEqual($prevLayout, nextLayout);\n\n  if (isMouseEvent(event) || isTouchEvent(event)) {\n    // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n    // In this case, Pane sizes might not change\u2013\n    // but updating cursor in this scenario would cause a flicker.\n    const $prevDelta = groupData.prevDelta.get();\n\n    if ($prevDelta != delta) {\n      groupData.prevDelta.set(delta);\n\n      if (!layoutChanged) {\n        // If the pointer has moved too far to resize the pane any further,\n        // update the cursor style for a visual clue.\n        // This mimics VS Code behavior.\n        if (isHorizontal) {\n          setGlobalCursorStyle(delta < 0 ? 'horizontal-min' : 'horizontal-max');\n        } else {\n          setGlobalCursorStyle(delta < 0 ? 'vertical-min' : 'vertical-max');\n        }\n      } else {\n        setGlobalCursorStyle(isHorizontal ? 'horizontal' : 'vertical');\n      }\n    }\n  }\n\n  if (layoutChanged) {\n    groupData.layout.set(nextLayout);\n  }\n}\n\nfunction startDragging(\n  direction: Writable<Direction>,\n  layout: Writable<number[]>,\n  dragHandleId: string,\n  event: ResizeEvent\n) {\n  const handleElement = getResizeHandleElement(dragHandleId);\n  assert(handleElement);\n\n  return {\n    dragHandleId,\n    dragHandleRect: handleElement.getBoundingClientRect(),\n    initialCursorPosition: getResizeEventCursorPosition(direction.get(), event),\n    initialLayout: layout.get()\n  } satisfies DragState;\n}\n\n// -- Helper functions\nfunction getPivotIndices(\n  groupId: string,\n  dragHandleId: string\n): [indexBefore: number, indexAfter: number] {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getDeltaPercentage(\n  e: ResizeEvent,\n  dragHandleId: string,\n  dir: Direction,\n  initialCursorPosition: number | null,\n  keyboardResizeBy: number | null\n): number {\n  if (isKeyDown(e)) {\n    const isHorizontal = dir === 'horizontal';\n\n    let delta = 0;\n    if (e.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n    } else {\n      delta = 5;\n    }\n\n    let movement = 0;\n    switch (e.key) {\n      case 'ArrowDown':\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case 'ArrowLeft':\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case 'ArrowRight':\n        movement = isHorizontal ? delta : 0;\n        break;\n      case 'ArrowUp':\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case 'End':\n        movement = 100;\n        break;\n      case 'Home':\n        movement = -100;\n        break;\n    }\n\n    return movement;\n  } else {\n    if (initialCursorPosition == null) return 0;\n\n    const isHorizontal = dir === 'horizontal';\n\n    const handleElement = getResizeHandleElement(dragHandleId);\n    assert(handleElement);\n\n    const groupId = handleElement.getAttribute('data-pane-group-id');\n    assert(groupId);\n\n    const cursorPosition = getResizeEventCursorPosition(dir, e);\n\n    const groupElement = getPaneGroupElement(groupId);\n    assert(groupElement);\n\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = (offsetPixels / groupSizeInPixels) * 100;\n\n    return offsetPercentage;\n  }\n}\n\nfunction getResizeEventCursorPosition(dir: Direction, e: ResizeEvent): number {\n  const isHorizontal = dir === 'horizontal';\n\n  if (isMouseEvent(e)) {\n    return isHorizontal ? e.clientX : e.clientY;\n  } else if (isTouchEvent(e)) {\n    const firstTouch = e.touches[0];\n    assert(firstTouch);\n    return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    throw Error(\n      `Unsupported event type \"${(e as { type?: string }).type ?? 'unknown'}\"`\n    );\n  }\n}\n\nfunction getResizeHandleElementsForGroup(groupId: string): HTMLElement[] {\n  return Array.from(\n    document.querySelectorAll(\n      `[data-pane-resizer-id][data-pane-group-id=\"${groupId}\"]`\n    )\n  );\n}\n\nfunction getResizeHandleElementIndex(\n  groupId: string,\n  id: string\n): number | null {\n  const handles = getResizeHandleElementsForGroup(groupId);\n  const index = handles.findIndex(\n    handle => handle.getAttribute('data-pane-resizer-id') === id\n  );\n  return index ?? null;\n}\n\nfunction getResizeHandleElement(id: string): HTMLElement | null {\n  const element = document.querySelector(\n    `[data-pane-resizer][data-pane-resizer-id=\"${id}\"]`\n  );\n  if (element) {\n    return element as HTMLElement;\n  }\n  return null;\n}\n\nfunction getPaneGroupElement(id: string): HTMLElement | null {\n  const element = document.querySelector(\n    `[data-pane-group][data-pane-group-id=\"${id}\"]`\n  );\n  if (element) {\n    return element as HTMLElement;\n  }\n  return null;\n}\n\nfunction handleKeydown(\n  groupId: GroupId,\n  resizeHandleId: ResizerId,\n  disabled: boolean,\n  resizeHandler: ResizeHandler | null,\n  event: KeyboardEvent\n) {\n  if (disabled || !resizeHandler || event.defaultPrevented) return;\n\n  const resizeKeys = [\n    'ArrowDown',\n    'ArrowLeft',\n    'ArrowRight',\n    'ArrowUp',\n    'End',\n    'Home'\n  ];\n\n  if (resizeKeys.includes(event.key)) {\n    event.preventDefault();\n    resizeHandler(event);\n    return;\n  }\n\n  if (event.key !== 'F6') return;\n\n  event.preventDefault();\n\n  const handles = getResizeHandleElementsForGroup(groupId);\n  const index = getResizeHandleElementIndex(groupId, resizeHandleId);\n\n  if (index === null) return;\n\n  const nextIndex = event.shiftKey\n    ? index > 0\n      ? index - 1\n      : handles.length - 1\n    : index + 1 < handles.length\n      ? index + 1\n      : 0;\n\n  const nextHandle = handles[nextIndex] as HTMLElement;\n  nextHandle.focus();\n}\n", "import type { Hook } from 'phoenix_live_view';\nimport { createGroupHook } from './hooks/group';\nimport { createPaneHook } from './hooks/pane';\nimport { createResizerHook } from './hooks/resizer';\n\nexport function createLivePaneHooks() {\n  let groupHook: Hook = createGroupHook();\n  let paneHook: Hook = createPaneHook();\n  let resizerHook: Hook = createResizerHook();\n\n  return { groupHook, paneHook, resizerHook };\n}\n"],
  "mappings": "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",
  "names": ["dragState", "paneConstraints", "delta", "pivotIndex", "prevSize", "unsafeSize", "safeSize", "paneData", "element", "resizeHandler"]
}
