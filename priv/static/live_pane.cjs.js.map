{
  "version": 3,
  "sources": ["../../assets/js/live_pane/index.ts", "../../assets/js/live_pane/utils.ts", "../../assets/js/live_pane/store.ts", "../../assets/js/live_pane/storage.ts", "../../assets/js/live_pane/core.ts", "../../assets/js/live_pane/compare.ts", "../../assets/js/live_pane/resize.ts", "../../assets/js/live_pane/aria.ts", "../../assets/js/live_pane/hooks/group.ts", "../../assets/js/live_pane/style.ts", "../../assets/js/live_pane/adjust-layout.ts", "../../assets/js/live_pane/hooks/pane.ts", "../../assets/js/live_pane/chain.ts", "../../assets/js/live_pane/event.ts", "../../assets/js/live_pane/hooks/resizer.ts", "../../assets/js/live_pane/live_pane.ts"],
  "sourcesContent": ["export * from './live_pane';\n", "import type { PaneData, PaneId, ResizeEvent } from './core';\n\nexport function noop() {}\n\nexport function assert(\n  expectedCondition: any,\n  message: string = 'Assertion failed!'\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nexport function safe_not_equal(a: any, b: any) {\n  return a != a\n    ? b == b\n    : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nexport function subscribe(store: any, ...callbacks: ((_: any) => any)[]) {\n  if (store == null) {\n    return noop;\n  }\n  const unsub = store.subscribe(...callbacks);\n  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\nexport function isHTMLElement(element: unknown): element is HTMLElement {\n  return element instanceof HTMLElement;\n}\n\nexport function isMouseEvent(event: ResizeEvent): event is MouseEvent {\n  return event.type.startsWith('mouse');\n}\n\nexport function isTouchEvent(event: ResizeEvent): event is TouchEvent {\n  return event.type.startsWith('touch');\n}\n\nexport function isKeyDown(event: ResizeEvent): event is KeyboardEvent {\n  return event.type === 'keydown';\n}\n\nexport function paneDataHelper(\n  paneDataArray: PaneData[],\n  paneData: PaneData,\n  layout: number[]\n) {\n  const paneConstraintsArray = paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  const paneIndex = findPaneDataIndex(paneDataArray, paneData.id);\n  const paneConstraints = paneConstraintsArray[paneIndex];\n\n  const isLastPane = paneIndex === paneDataArray.length - 1;\n  const pivotIndices = isLastPane\n    ? [paneIndex - 1, paneIndex]\n    : [paneIndex, paneIndex + 1];\n\n  const paneSize = layout[paneIndex];\n\n  return {\n    ...paneConstraints,\n    paneSize,\n    pivotIndices\n  };\n}\n\nexport function findPaneDataIndex(\n  paneDataArray: PaneData[],\n  paneDataId: PaneId\n) {\n  return paneDataArray.findIndex(p => p.id === paneDataId);\n}\n\nexport function isPaneCollapsed(\n  paneDataArray: PaneData[],\n  layout: number[],\n  pane: PaneData\n) {\n  const {\n    collapsedSize = 0,\n    collapsible,\n    paneSize\n  } = paneDataHelper(paneDataArray, pane, layout);\n\n  return collapsible === true && paneSize === collapsedSize;\n}\n\nexport function isPaneExpanded(\n  paneDataArray: PaneData[],\n  layout: number[],\n  pane: PaneData\n) {\n  const {\n    collapsedSize = 0,\n    collapsible,\n    paneSize\n  } = paneDataHelper(paneDataArray, pane, layout);\n  return !collapsible || paneSize > collapsedSize;\n}\n\nexport function tick(): Promise<void> {\n  return new Promise(resolve => {\n    requestAnimationFrame(() => {\n      // Wait one more frame to ensure DOM is updated\n      requestAnimationFrame(() => {\n        resolve();\n      });\n    });\n  });\n}\n", "import { safe_not_equal } from './utils';\n\n/** Callback to inform of a value updates. */\nexport type Subscriber<T> = (value: T) => void;\n\n/** Unsubscribes from value updates. */\nexport type Unsubscriber = () => void;\n\n/** Writable interface for both updating and subscribing. */\nexport interface Writable<T> {\n  set(this: void, value: T): void;\n\n  get(this: void): T;\n\n  update(this: void, updater: (value: T) => T): void;\n\n  subscribe(this: void, run: Subscriber<T>): Unsubscriber;\n}\n\nexport function writable<T>(value: T): Writable<T> {\n  const subscribers: Set<Subscriber<T>> = new Set();\n\n  function set(new_value: T): void {\n    if (safe_not_equal(value, new_value)) {\n      value = new_value;\n      for (const subscriber of subscribers) {\n        subscriber(new_value);\n      }\n    }\n  }\n\n  function get(): T {\n    return value as T;\n  }\n\n  function update(fn: (value: T) => T): void {\n    set(fn(value));\n  }\n\n  function subscribe(subscriber: Subscriber<T>): Unsubscriber {\n    subscribers.add(subscriber);\n    subscriber(value);\n\n    return () => {\n      subscribers.delete(subscriber);\n    };\n  }\n\n  return { set, get, update, subscribe };\n}\n", "import { LOCAL_STORAGE_DEBOUNCE_INTERVAL, type PaneData } from './core';\nimport { Writable } from './store';\n\nexport type PaneConfigState = {\n  expandToSizes: { [paneId: string]: number };\n  layout: number[];\n};\n\nexport type SerializedPaneGroupState = {\n  [paneIds: string]: PaneConfigState;\n};\n\nexport type PaneGroupStorage = {\n  getItem(name: string): string | null;\n  setItem(name: string, value: string): void;\n};\n\n/**\n * Initializes the storage object with the appropriate getItem\n *  and setItem functions depending on the environment (browser or not).\n */\nexport function initializeStorage(storageObject: PaneGroupStorage): void {\n  try {\n    if (typeof localStorage === 'undefined') {\n      throw new Error('localStorage is not supported in this environment');\n    }\n\n    storageObject.getItem = (name: string) => localStorage.getItem(name);\n    storageObject.setItem = (name: string, value: string) =>\n      localStorage.setItem(name, value);\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\n/**\n * Saves the pane group state to local storage.\n */\nexport function savePaneGroupState(\n  autoSaveId: string,\n  panes: PaneData[],\n  paneSizesBeforeCollapse: Map<string, number>,\n  sizes: number[],\n  storage: PaneGroupStorage\n): void {\n  const paneGroupKey = getPaneGroupKey(autoSaveId);\n  const paneKey = getPaneKey(panes);\n  const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n  state[paneKey] = {\n    expandToSizes: Object.fromEntries(paneSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n\n  try {\n    storage.setItem(paneGroupKey, JSON.stringify(state));\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error(error);\n  }\n}\n\n/**\n * Loads the pane group state from local storage.\n * If the state is not found, returns null.\n */\nexport function loadPaneGroupState(\n  autoSaveId: string,\n  panes: PaneData[],\n  storage: PaneGroupStorage\n): PaneConfigState | null {\n  const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n  const paneKey = getPaneKey(panes);\n  return state[paneKey] || null;\n}\n\n/**\n * Returns the key to use for storing the pane group state in local storage.\n */\nfunction getPaneGroupKey(id: string): string {\n  return `livepane:${id}`;\n}\n\n/**\n * Returns a key to use for storing the pane state in local storage.\n * The key is based on the pane order and constraints.\n */\nfunction getPaneKey(panes: PaneData[]): string {\n  const sortedPaneIds = panes\n    .map(({ id }) => id)\n    .sort()\n    .join(',');\n  return sortedPaneIds;\n}\n\n/**\n * Loads the serialized pane group state from local storage.\n * If the state is not found, returns null.\n */\nfunction loadSerializedPaneGroupState(\n  autoSaveId: string,\n  storage: PaneGroupStorage\n): SerializedPaneGroupState | null {\n  try {\n    const paneGroupKey = getPaneGroupKey(autoSaveId);\n    const serialized = storage.getItem(paneGroupKey);\n    const parsed = JSON.parse(serialized || '');\n    if (typeof parsed === 'object' && parsed !== null) {\n      return parsed as SerializedPaneGroupState;\n    }\n  } catch {\n    // noop\n  }\n\n  return null;\n}\n\nconst debounceMap: {\n  [key: string]: typeof savePaneGroupState;\n} = {};\n\n/**\n * Returns a debounced version of the given function.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction debounce<T extends Function>(callback: T, durationMs: number = 10) {\n  let timeoutId: number | null | undefined = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const callable = (...args: any) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n\n  return callable as unknown as T;\n}\n\n/**\n * Updates the values in local storage based on the current state of\n * the pane group.\n * This function is debounced to limit the frequency of local storage writes.\n */\nexport function updateStorageValues({\n  saveId,\n  layout,\n  storage,\n  paneDataArrayStore,\n  paneSizeBeforeCollapseStore\n}: {\n  saveId: string;\n  layout: number[];\n  storage: PaneGroupStorage;\n  paneDataArrayStore: Writable<PaneData[]>;\n  paneSizeBeforeCollapseStore: Writable<Map<string, number>>;\n}) {\n  const $paneDataArray = paneDataArrayStore.get();\n\n  // If this pane has been configured to persist sizing\n  // information, save sizes to local storage.\n\n  if (layout.length === 0 || layout.length !== $paneDataArray.length) return;\n\n  let debouncedSave = debounceMap[saveId];\n\n  // Limit frequency of local storage writes.\n  if (debouncedSave == null) {\n    debouncedSave = debounce(\n      savePaneGroupState,\n      LOCAL_STORAGE_DEBOUNCE_INTERVAL\n    );\n    debounceMap[saveId] = debouncedSave;\n  }\n\n  // Clone mutable data before passing to the debounced function,\n  // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n  const clonedPaneDataArray = [...$paneDataArray];\n\n  const $paneSizeBeforeCollapse = paneSizeBeforeCollapseStore.get();\n  const clonedPaneSizesBeforeCollapse = new Map($paneSizeBeforeCollapse);\n  debouncedSave(\n    saveId,\n    clonedPaneDataArray,\n    clonedPaneSizesBeforeCollapse,\n    layout,\n    storage\n  );\n}\n", "import { initializeStorage, PaneGroupStorage } from './storage';\nimport { Unsubscriber, writable, type Writable } from './store';\n\nexport const LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nexport const PRECISION = 10;\n\nexport const paneGroupInstances = new Map<GroupId, PaneGroupData>();\nexport const paneInstances = new Map<PaneId, PaneManagementData>();\nexport const resizerInstances = new Map<ResizerId, ResizerData>();\nexport const dragState: Writable<DragState | null> = writable(null);\n\nexport type PaneManagementData = {\n  groupId: string;\n  unsubs: Unsubscriber[];\n};\nexport type ResizerData = {\n  disabled: Writable<boolean>;\n  resizeHandlerCallback: ResizeHandler | null;\n  isDragging: Writable<boolean>;\n  unsubs: Unsubscriber[];\n  isFocused: Writable<boolean>;\n};\n\nexport type GroupId = string;\nexport type PaneId = string;\nexport type ResizerId = string;\n\nexport type PaneGroupData = {\n  paneDataArray: Writable<PaneData[]>;\n  paneDataArrayChanged: Writable<boolean>;\n  direction: Writable<Direction>;\n  layout: Writable<number[]>;\n  prevDelta: Writable<number>;\n  keyboardResizeBy: number | null;\n\n  paneIdToLastNotifiedSizeMap: Record<string, number>;\n  paneSizeBeforeCollapseMap: Writable<Map<string, number>>;\n\n  autoSave: boolean;\n\n  unsubFromPaneDataChange: Unsubscriber;\n  unsubFromLayoutChange: Unsubscriber;\n  unsubFromUpdateAriaValues: Unsubscriber;\n  unsubFromUpdateIsCollapsed: Unsubscriber;\n};\n\nexport type Direction = 'horizontal' | 'vertical';\n\nexport type DragState = {\n  dragHandleId: string;\n  dragHandleRect: DOMRect;\n  initialCursorPosition: number;\n  initialLayout: number[];\n};\n\nexport type PaneConstraints = {\n  collapsedSize: number;\n  collapsible: boolean;\n  defaultSize?: number;\n  maxSize: number;\n  minSize: number;\n};\n\nexport type PaneData = {\n  id: string;\n  order: number;\n  constraints: PaneConstraints;\n  state: Writable<PaneState>;\n};\n\nexport const enum PaneState {\n  Collapsing = 'collapsing',\n  Expanding = 'expanding',\n  Collapsed = 'collapsed',\n  Expanded = 'expanded'\n}\n\nexport type ResizeEvent = KeyboardEvent | MouseEvent | TouchEvent;\nexport type ResizeHandler = (event: ResizeEvent) => void;\n\nexport type PaneResizeHandleOnDragging = (isDragging: boolean) => void;\n\nexport type PaneOnCollapse = () => void;\nexport type PaneOnExpand = () => void;\nexport type PaneOnResize = (size: number, prevSize: number | undefined) => void;\n\nexport type CollapseEvent = {\n  paneId: string;\n};\n\nexport const defaultStorage: PaneGroupStorage = {\n  getItem: (name: string) => {\n    initializeStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name: string, value: string) => {\n    initializeStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\n", "import { PRECISION } from './core';\n\n/**\n * Compares two numbers for equality with a given fractional precision.\n */\nexport function areNumbersAlmostEqual(\n  actual: number,\n  expected: number,\n  fractionDigits: number = PRECISION\n): boolean {\n  return compareNumbersWithTolerance(actual, expected, fractionDigits) === 0;\n}\n\n/**\n * Compares two numbers with a given tolerance.\n *\n * @returns `-1` if `actual` is less than `expected`, `0` if they are equal,\n * and `1` if `actual` is greater than `expected`.\n */\nexport function compareNumbersWithTolerance(\n  actual: number,\n  expected: number,\n  fractionDigits: number = PRECISION\n): number {\n  const roundedActual = roundTo(actual, fractionDigits);\n  const roundedExpected = roundTo(expected, fractionDigits);\n\n  return Math.sign(roundedActual - roundedExpected);\n}\n\n/**\n * Compares two arrays for equality.\n */\nexport function areArraysEqual<T extends Array<unknown>>(\n  arrA: T,\n  arrB: T\n): boolean {\n  if (arrA.length !== arrB.length) return false;\n\n  for (let index = 0; index < arrA.length; index++) {\n    if (arrA[index] !== arrB[index]) return false;\n  }\n\n  return true;\n}\n\n/**\n * Rounds a number to a given number of decimal places.\n */\nfunction roundTo(value: number, decimals: number): number {\n  return parseFloat(value.toFixed(decimals));\n}\n", "import { PRECISION } from './core';\nimport type { PaneConstraints } from './core';\nimport { assert } from './utils';\nimport { compareNumbersWithTolerance } from './compare';\n\ntype ResizePaneArgs = {\n  paneConstraintsArray: PaneConstraints[];\n  paneIndex: number;\n  size: number;\n};\n/**\n * Resizes a pane based on its constraints.\n */\nexport function resizePane({\n  paneConstraintsArray: constraints,\n  paneIndex,\n  size\n}: ResizePaneArgs): number {\n  assert(\n    constraints[paneIndex] != null,\n    'Pane constraints should not be null.'\n  );\n\n  const { collapsedSize, collapsible, maxSize, minSize } =\n    constraints[paneIndex];\n\n  let newSize = size;\n\n  if (compareNumbersWithTolerance(newSize, minSize) < 0) {\n    newSize = getAdjustedSizeForCollapsible(\n      newSize,\n      collapsible,\n      collapsedSize,\n      minSize\n    );\n  }\n\n  newSize = Math.min(maxSize, newSize);\n  return parseFloat(newSize.toFixed(PRECISION));\n}\n\n/**\n * Adjusts the size of a pane based on its collapsible state.\n *\n * If the pane is collapsible, the size will be snapped to the collapsed size\n * or the minimum size based on the halfway point.\n */\nfunction getAdjustedSizeForCollapsible(\n  size: number,\n  collapsible: boolean,\n  collapsedSize: number,\n  minSize: number\n): number {\n  if (!collapsible) return minSize;\n\n  // Snap collapsible panes closed or open based on the halfway point.\n  const halfwayPoint = (collapsedSize + minSize) / 2;\n  return compareNumbersWithTolerance(size, halfwayPoint) < 0\n    ? collapsedSize\n    : minSize;\n}\n", "import type { PaneData } from './core';\n\n/**\n * A utility function that calculates the `aria-valuemax`, `aria-valuemin`,\n * and `aria-valuenow` values for a pane based on its layout and constraints.\n */\nexport function calculateAriaValues({\n  layout,\n  panesArray,\n  pivotIndices\n}: {\n  layout: number[];\n  panesArray: PaneData[];\n  pivotIndices: number[];\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n\n  const firstIndex = pivotIndices[0];\n\n  // A pane's effective min/max sizes also need to account for other pane's sizes.\n  for (let i = 0; i < panesArray.length; i++) {\n    const { constraints } = panesArray[i];\n    const { maxSize = 100, minSize = 0 } = constraints;\n\n    if (i === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  }\n\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n\n  const valueNow = layout[firstIndex];\n\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n", "import { Hook } from 'phoenix_live_view';\nimport { Unsubscriber, Writable, writable } from '../store';\nimport type {\n  Direction,\n  PaneData,\n  PaneGroupData,\n  PaneConstraints\n} from '../core';\nimport { defaultStorage, paneGroupInstances, PaneState } from '../core';\n\nimport { areArraysEqual, areNumbersAlmostEqual } from '../compare';\nimport {\n  assert,\n  isHTMLElement,\n  isPaneCollapsed,\n  isPaneExpanded,\n  paneDataHelper\n} from '../utils';\nimport { resizePane } from '../resize';\nimport {\n  loadPaneGroupState,\n  PaneGroupStorage,\n  updateStorageValues\n} from '../storage';\nimport { calculateAriaValues } from '../aria';\n\nexport function createGroupHook() {\n  let groupHook: Hook = {\n    mounted() {\n      if (!this.el.id) {\n        throw Error('Pane Group must have an id.');\n      }\n      if (paneGroupInstances.has(this.el.id)) {\n        throw Error(`Pane Group with id \"${this.el.id}\" already exists.`);\n      }\n\n      const dir = this.el.getAttribute('data-pane-direction') || 'horizontal';\n      const keyboardResizeByAttr = this.el.getAttribute('keyboard-resize-by');\n      const keyboardResizeBy: number | null = keyboardResizeByAttr\n        ? Number(keyboardResizeByAttr)\n        : null;\n\n      const autoSave = this.el.getAttribute('auto-save') === 'true';\n\n      const paneDataArray = writable<PaneData[]>([]);\n      const paneDataArrayChanged = writable(false);\n\n      const direction = writable<Direction>(dir as Direction);\n      const layout = writable<number[]>([]);\n      const prevDelta = writable<number>(0);\n\n      const paneIdToLastNotifiedSizeMap: Record<string, number> = {};\n      const paneSizeBeforeCollapseMap: Writable<Map<string, number>> = writable(\n        new Map<string, number>()\n      );\n\n      const unsubFromPaneDataChange = updateLayoutOnPaneDataChange(\n        this.el.id,\n        layout,\n        paneDataArray,\n        paneDataArrayChanged,\n        autoSave,\n        paneSizeBeforeCollapseMap\n      );\n\n      const unsubFromLayoutChange = saveStateOnLayoutChange(\n        this.el.id,\n        layout,\n        paneDataArray,\n        paneSizeBeforeCollapseMap,\n        autoSave\n      );\n\n      const unsubFromUpdateAriaValues =\n        updateResizeHandleAriaValuesOnLayoutChange(\n          this.el.id,\n          layout,\n          paneDataArray\n        );\n\n      const unsubFromUpdateIsCollapsed = updateIsCollapsedOnLayoutChange(\n        layout,\n        paneDataArray\n      );\n\n      const groupData: PaneGroupData = {\n        paneDataArray,\n        paneDataArrayChanged,\n        direction,\n        layout,\n        prevDelta,\n        keyboardResizeBy,\n        paneIdToLastNotifiedSizeMap,\n        paneSizeBeforeCollapseMap,\n        autoSave,\n        unsubFromPaneDataChange,\n        unsubFromLayoutChange,\n        unsubFromUpdateAriaValues,\n        unsubFromUpdateIsCollapsed\n      };\n\n      paneGroupInstances.set(this.el.id, groupData);\n    },\n\n    destroyed() {\n      paneGroupInstances.get(this.el.id)?.unsubFromUpdateIsCollapsed();\n      paneGroupInstances.get(this.el.id)?.unsubFromPaneDataChange();\n      paneGroupInstances.get(this.el.id)?.unsubFromLayoutChange();\n      paneGroupInstances.get(this.el.id)?.unsubFromUpdateAriaValues();\n      paneGroupInstances.delete(this.el.id);\n    }\n  };\n\n  return groupHook;\n}\n\nfunction saveStateOnLayoutChange(\n  groupId: string,\n  layout: Writable<number[]>,\n  paneDataArray: Writable<PaneData[]>,\n  paneSizeBeforeCollapseMap: Writable<Map<string, number>>,\n  autoSave: boolean = false,\n  storage: PaneGroupStorage = defaultStorage\n): Unsubscriber {\n  return layout.subscribe(layout => {\n    if (!autoSave) return;\n    updateStorageValues({\n      saveId: groupId,\n      layout,\n      storage,\n      paneDataArrayStore: paneDataArray,\n      paneSizeBeforeCollapseStore: paneSizeBeforeCollapseMap\n    });\n  });\n}\n\nfunction updateLayoutOnPaneDataChange(\n  groupId: string,\n  layout: Writable<number[]>,\n  paneDataArray: Writable<PaneData[]>,\n  paneDataArrayChanged: Writable<boolean>,\n  autoSave: boolean = false,\n  paneSizeBeforeCollapseMap: Writable<Map<string, number>>\n) {\n  return paneDataArrayChanged.subscribe(changed => {\n    if (!changed) return;\n    paneDataArrayChanged.set(false);\n\n    const $prevLayout = layout.get();\n    const $paneDataArray = paneDataArray.get();\n\n    let unsafeLayout: number[] | null = null;\n\n    if (autoSave) {\n      const state = loadPaneGroupState(groupId, $paneDataArray, defaultStorage);\n      if (state) {\n        paneSizeBeforeCollapseMap.set(\n          new Map(Object.entries(state.expandToSizes))\n        );\n        unsafeLayout = state.layout;\n      }\n    }\n\n    if (unsafeLayout == null) {\n      unsafeLayout = getUnsafeDefaultLayout({\n        paneDataArray: $paneDataArray\n      });\n    }\n\n    // Validate even saved layouts in case something has changed since last render\n    const nextLayout = validatePaneGroupLayout({\n      layout: unsafeLayout,\n      paneConstraintsArray: $paneDataArray.map(paneData => paneData.constraints)\n    });\n\n    if (areArraysEqual($prevLayout, nextLayout)) return;\n\n    layout.set(nextLayout);\n  });\n}\n\nfunction updateIsCollapsedOnLayoutChange(\n  layout: Writable<number[]>,\n  paneDataArray: Writable<PaneData[]>\n) {\n  return layout.subscribe(changedLayout => {\n    const paneDatas = paneDataArray.get();\n\n    for (let index = 0; index <= paneDatas.length - 1; index++) {\n      const paneData = paneDatas[index];\n      const isCollapsed = isPaneCollapsed(paneDatas, changedLayout, paneData);\n      if (isCollapsed && paneData.state.get() !== PaneState.Collapsing) {\n        paneData.state.set(PaneState.Collapsed);\n        continue;\n      }\n\n      const isExpanded = isPaneExpanded(paneDatas, changedLayout, paneData);\n      if (isExpanded && paneData.state.get() !== PaneState.Expanding) {\n        paneData.state.set(PaneState.Expanded);\n      }\n    }\n  });\n}\n\nfunction updateResizeHandleAriaValuesOnLayoutChange(\n  groupId: string,\n  layout: Writable<number[]>,\n  paneDataArray: Writable<PaneData[]>\n): Unsubscriber {\n  return layout.subscribe(currentLayout => {\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId);\n    const paneDatas = paneDataArray.get();\n\n    for (let index = 0; index < paneDatas.length - 1; index++) {\n      const { valueMax, valueMin, valueNow } = calculateAriaValues({\n        layout: currentLayout,\n        panesArray: paneDatas,\n        pivotIndices: [index, index + 1]\n      });\n\n      const resizeHandleEl = resizeHandleElements[index];\n\n      if (isHTMLElement(resizeHandleEl)) {\n        const paneData = paneDatas[index];\n\n        resizeHandleEl.setAttribute('aria-controls', paneData.id);\n        resizeHandleEl.setAttribute('aria-valuemax', '' + Math.round(valueMax));\n        resizeHandleEl.setAttribute('aria-valuemin', '' + Math.round(valueMin));\n        resizeHandleEl.setAttribute(\n          'aria-valuenow',\n          valueNow != null ? '' + Math.round(valueNow) : ''\n        );\n      }\n    }\n  });\n}\n\nfunction getUnsafeDefaultLayout({\n  paneDataArray\n}: { paneDataArray: PaneData[] }): number[] {\n  const layout = Array<number>(paneDataArray.length);\n\n  const paneConstraintsArray = paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  let numPanesWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < paneDataArray.length; index++) {\n    const paneConstraints = paneConstraintsArray[index];\n    assert(paneConstraints);\n    const { defaultSize } = paneConstraints;\n\n    if (defaultSize != null) {\n      numPanesWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panes without default sizes\n  for (let index = 0; index < paneDataArray.length; index++) {\n    const paneConstraints = paneConstraintsArray[index];\n    assert(paneConstraints);\n    const { defaultSize } = paneConstraints;\n\n    if (defaultSize != null) {\n      continue;\n    }\n\n    const numRemainingPanes = paneDataArray.length - numPanesWithSizes;\n    const size = remainingSize / numRemainingPanes;\n\n    numPanesWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n\n  return layout;\n}\n\n// All units must be in percentages\nfunction validatePaneGroupLayout({\n  layout: prevLayout,\n  paneConstraintsArray\n}: {\n  layout: number[];\n  paneConstraintsArray: PaneConstraints[];\n}): number[] {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce(\n    (accumulated, current) => accumulated + current,\n    0\n  );\n\n  // Validate layout expectations\n  if (nextLayout.length !== paneConstraintsArray.length) {\n    throw Error(\n      `Invalid ${paneConstraintsArray.length} pane layout: ${nextLayout\n        .map(size => `${size}%`)\n        .join(', ')}`\n    );\n  } else if (!areNumbersAlmostEqual(nextLayoutTotalSize, 100)) {\n    for (let index = 0; index < paneConstraintsArray.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null);\n      const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each pane's constraints\n  for (let index = 0; index < paneConstraintsArray.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null);\n\n    const safeSize = resizePane({\n      paneConstraintsArray,\n      paneIndex: index,\n      size: unsafeSize\n    });\n\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any pane(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!areNumbersAlmostEqual(remainingSize, 0)) {\n    for (let index = 0; index < paneConstraintsArray.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePane({\n        paneConstraintsArray,\n        paneIndex: index,\n        size: unsafeSize\n      });\n\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (areNumbersAlmostEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n\n  return nextLayout;\n}\n\nexport function getResizeHandleElementsForGroup(\n  groupId: string\n): HTMLElement[] {\n  return Array.from(\n    document.querySelectorAll(\n      `[data-pane-resizer-id][data-pane-group-id=\"${groupId}\"]`\n    )\n  );\n}\n", "import type { DragState, PaneData } from './core';\n\n/**\n * A utility function that converts a style object to a string,\n * which can be used as the value of the `style` attribute for\n * an element.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style: StyleObject): string {\n  return Object.keys(style).reduce((str, key) => {\n    if (style[key] === undefined) return str;\n    return str + `${key}:${style[key]};`;\n  }, '');\n}\n\nexport type StyleObject = Record<string, number | string | undefined>;\n\ntype CursorState =\n  | 'horizontal'\n  | 'horizontal-max'\n  | 'horizontal-min'\n  | 'vertical'\n  | 'vertical-max'\n  | 'vertical-min';\n\n/* Global cursor state */\nlet currentState: CursorState | null = null;\n\n/**\n * Returns the cursor style for a given cursor state.\n */\nexport function getCursorStyle(state: CursorState): string {\n  switch (state) {\n    case 'horizontal':\n      return 'ew-resize';\n    case 'horizontal-max':\n      return 'w-resize';\n    case 'horizontal-min':\n      return 'e-resize';\n    case 'vertical':\n      return 'ns-resize';\n    case 'vertical-max':\n      return 'n-resize';\n    case 'vertical-min':\n      return 's-resize';\n  }\n}\n\n/**\n * Resets the global cursor style to the default.\n */\nexport function resetGlobalCursorStyle() {\n  if (!currentState) return;\n\n  document.documentElement.style.cursor = '';\n  currentState = null;\n}\n\n/**\n * Sets the global cursor style to the given state.\n */\nexport function setGlobalCursorStyle(state: CursorState) {\n  if (currentState === state) return;\n\n  const root = document.documentElement;\n  if (currentState) {\n    root.style.cursor = '';\n  }\n  root.style.cursor = getCursorStyle(state);\n  currentState = state;\n}\n\n/**\n * Computes the flexbox style for a pane given its layout and drag state.\n */\nexport function computePaneFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  paneData,\n  paneIndex,\n  precision = 3\n}: {\n  defaultSize: number | undefined;\n  layout: number[];\n  dragState: DragState | null;\n  paneData: PaneData[];\n  paneIndex: number;\n  precision?: number;\n}): string {\n  const size = layout[paneIndex];\n\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panes have registered themselves)\n    // To support server rendering, fallback to default size\n    flexGrow = defaultSize ?? '1';\n  } else if (paneData.length === 1) {\n    //  Single pane group should always fill full width/height\n    flexGrow = '1';\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n\n  return styleToString({\n    'flex-basis': 0,\n    'flex-grow': flexGrow,\n    'flex-shrink': 1,\n    // Without this, pane sizes may be unintentionally overridden by their content\n    overflow: 'hidden',\n    // Disable pointer events inside of a pane during resize\n    // This avoid edge cases like nested iframes\n    'pointer-events': dragState !== null ? 'none' : undefined\n  });\n}\n", "import type { PaneConstraints } from './core';\nimport { assert } from './utils';\nimport { compareNumbersWithTolerance, areNumbersAlmostEqual } from './compare';\nimport { resizePane } from './resize';\n\ntype AdjustLayoutByDeltaArgs = {\n  delta: number;\n  layout: number[];\n  paneConstraintsArray: PaneConstraints[];\n  pivotIndices: number[];\n  trigger: 'imperative-api' | 'keyboard' | 'mouse-or-touch';\n};\n/**\n * Adjusts the layout of panes based on the delta of the resize handle.\n * All units must be in percentages; pixel values should be pre-converted.\n *\n * Credit: https://github.com/bvaughn/react-resizable-panels\n */\nexport function adjustLayoutByDelta({\n  delta,\n  layout: prevLayout,\n  paneConstraintsArray,\n  pivotIndices,\n  trigger\n}: AdjustLayoutByDeltaArgs): number[] {\n  if (areNumbersAlmostEqual(delta, 0)) return prevLayout;\n\n  const nextLayout = [...prevLayout];\n\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, 'Invalid first pivot index');\n  assert(secondPivotIndex != null, 'Invalid second pivot index');\n\n  let deltaApplied = 0;\n\n  // A resizing pane affects the panes before or after it.\n  //\n  // A negative delta means the pane(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panes may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the pane(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panes after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the pane from expanding at all.\n    if (trigger === 'keyboard') {\n      {\n        // Check if we should expand a collapsed pane\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n\n        if (paneConstraints.collapsible) {\n          const prevSize = prevLayout[index];\n          assert(prevSize != null);\n\n          const paneConstraints = paneConstraintsArray[index];\n          assert(paneConstraints);\n          const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n\n          if (areNumbersAlmostEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n\n            if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a pane at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { collapsible } = paneConstraints;\n\n        if (collapsible) {\n          const prevSize = prevLayout[index];\n          assert(prevSize != null);\n\n          const paneConstraints = paneConstraintsArray[index];\n          assert(paneConstraints);\n          const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n\n          if (areNumbersAlmostEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n\n            if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panes in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too\u2013\n    // as an expanding pane might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    while (true) {\n      const prevSize = prevLayout[index];\n      assert(prevSize != null);\n\n      const maxSafeSize = resizePane({\n        paneConstraintsArray,\n        paneIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n\n      maxAvailableDelta += delta;\n      index += increment;\n\n      if (index < 0 || index >= paneConstraintsArray.length) {\n        break;\n      }\n    }\n\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n\n  {\n    // Delta added to a pane needs to be subtracted from other panes (within the constraints that those panes allow).\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < paneConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n\n      const prevSize = prevLayout[index];\n      assert(prevSize != null);\n\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePane({\n        paneConstraintsArray,\n        paneIndex: index,\n        size: unsafeSize\n      });\n\n      if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n\n        nextLayout[index] = safeSize;\n\n        if (\n          deltaApplied\n            .toPrecision(3)\n            .localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n              numeric: true\n            }) >= 0\n        ) {\n          break;\n        }\n      }\n\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panes, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a pane's boundaries\n  if (areNumbersAlmostEqual(deltaApplied, 0)) {\n    return prevLayout;\n  }\n\n  {\n    // Now distribute the applied delta to the panes in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n\n    const prevSize = prevLayout[pivotIndex];\n    assert(prevSize != null);\n\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePane({\n      paneConstraintsArray,\n      paneIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot pane before, but only by the amount that surrounding panes were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one pane caused another one to change collapsed state\n    if (!areNumbersAlmostEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < paneConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null);\n\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePane({\n          paneConstraintsArray,\n          paneIndex: index,\n          size: unsafeSize\n        });\n\n        if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n\n        if (areNumbersAlmostEqual(deltaRemaining, 0)) break;\n\n        delta > 0 ? index-- : index++;\n      }\n    }\n  }\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n\n  if (!areNumbersAlmostEqual(totalSize, 100)) return prevLayout;\n\n  return nextLayout;\n}\n", "import { Hook } from 'phoenix_live_view';\nimport {\n  PaneData,\n  PaneGroupData,\n  PaneId,\n  paneInstances,\n  PaneState\n} from '../core';\nimport { writable, Writable } from '../store';\nimport { dragState, paneGroupInstances } from '../core';\nimport { computePaneFlexBoxStyle } from '../style';\nimport {\n  assert,\n  findPaneDataIndex,\n  isPaneCollapsed,\n  paneDataHelper,\n  tick\n} from '../utils';\nimport { adjustLayoutByDelta } from '../adjust-layout';\nimport { areArraysEqual } from '../compare';\n\nexport function createPaneHook() {\n  let paneHook: Hook = {\n    mounted() {\n      const groupId = this.el.getAttribute('data-pane-group-id');\n      if (!groupId) {\n        throw Error('data-pane-group-id must exist for pane components!');\n      }\n      const paneId = this.el.id;\n      if (!paneId) {\n        throw Error('Id must exist for pane components!');\n      }\n      const orderAttr = this.el.getAttribute('data-pane-order');\n      const order = orderAttr ? Number(orderAttr) : 0;\n\n      const groupData = paneGroupInstances.get(groupId);\n      if (!groupData) {\n        throw Error('Group with id \"' + groupId + '\" does not exist.');\n      }\n\n      const collapsedSize = Number(this.el.getAttribute('collapsed-size')) || 0;\n      const collapsible = this.el.getAttribute('collapsible') === 'true';\n      const defaultSize =\n        Number(this.el.getAttribute('default-size')) || undefined;\n      const maxSize = Number(this.el.getAttribute('max-size')) || 100;\n      const minSize = Number(this.el.getAttribute('min-size')) || 0;\n\n      let startingState = PaneState.Expanded;\n      if (defaultSize && collapsible && defaultSize <= collapsedSize) {\n        startingState = PaneState.Collapsed;\n      }\n      const paneData: PaneData = {\n        id: this.el.id,\n        order,\n        constraints: {\n          collapsedSize,\n          collapsible,\n          defaultSize,\n          maxSize,\n          minSize\n        },\n        state: writable(startingState)\n      };\n\n      registerPane(\n        paneData,\n        groupData.paneDataArray,\n        groupData.paneDataArrayChanged\n      );\n\n      const unsubs = setupReactivePaneStyle(\n        this.el,\n        groupData,\n        paneData,\n        defaultSize\n      );\n\n      const unsubFromPaneState = paneData.state.subscribe(state => {\n        const onCollapseEncodedJS = this.el.getAttribute('on-collapse');\n        if (onCollapseEncodedJS && state === PaneState.Collapsed) {\n          this.liveSocket.execJS(this.el, onCollapseEncodedJS);\n          this.el.setAttribute('data-pane-state', 'collapsed');\n          return;\n        }\n\n        const onExpandEncodedJS = this.el.getAttribute('on-expand');\n        if (onExpandEncodedJS && state === PaneState.Expanded) {\n          this.liveSocket.execJS(this.el, onExpandEncodedJS);\n          this.el.setAttribute('data-pane-state', 'expanded');\n          return;\n        }\n\n        this.el.setAttribute('data-pane-state', state);\n      });\n\n      unsubs.push(unsubFromPaneState);\n\n      paneInstances.set(paneId, { groupId, unsubs });\n\n      this.handleEvent('collapse', ({ pane_id }: { pane_id: string }) => {\n        if (paneId === pane_id) {\n          handleTransition(\n            this.el,\n            groupData.paneDataArray,\n            groupData.layout,\n            paneData,\n            PaneState.Collapsing\n          );\n          collapsePane(paneData, groupData);\n        }\n      });\n      this.handleEvent('expand', ({ pane_id }: { pane_id: string }) => {\n        if (paneId === pane_id) {\n          handleTransition(\n            this.el,\n            groupData.paneDataArray,\n            groupData.layout,\n            paneData,\n            PaneState.Expanding\n          );\n          expandPane(paneData, groupData);\n        }\n      });\n    },\n\n    updated() {\n      const groupId = this.el.getAttribute('data-pane-group-id');\n      const groupData = paneGroupInstances.get(groupId!);\n      const defaultSize =\n        Number(this.el.getAttribute('default-size')) || undefined;\n\n      const paneIndex = findPaneDataIndex(\n        groupData!.paneDataArray.get(),\n        this.el.id\n      );\n\n      const style = computePaneFlexBoxStyle({\n        defaultSize,\n        dragState: dragState.get(),\n        layout: groupData!.layout.get(),\n        paneData: groupData!.paneDataArray.get(),\n        paneIndex\n      });\n\n      this.el.style.cssText = style;\n    },\n\n    destroyed() {\n      const { groupId, unsubs } = paneInstances.get(this.el.id)!;\n      for (const unsub of unsubs) {\n        unsub();\n      }\n      const groupData = paneGroupInstances.get(groupId);\n      if (groupData) {\n        unregisterPane(\n          this.el.id,\n          groupData.paneDataArray,\n          groupData.paneDataArrayChanged\n        );\n      }\n      paneInstances.delete(this.el.id);\n    }\n  };\n  return paneHook;\n}\n\nfunction registerPane(\n  paneData: PaneData,\n  paneDataArray: Writable<PaneData[]>,\n  paneDataArrayChanged: Writable<boolean>\n) {\n  paneDataArray.update(curr => {\n    const newArr = [...curr, paneData];\n    newArr.sort((paneA, paneB) => {\n      const orderA = paneA.order;\n      const orderB = paneB.order;\n\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    return newArr;\n  });\n  paneDataArrayChanged.set(true);\n}\n\nfunction unregisterPane(\n  paneId: PaneId,\n  paneDataArray: Writable<PaneData[]>,\n  paneDataArrayChanged: Writable<boolean>\n) {\n  const $paneDataArray = paneDataArray.get();\n  const index = findPaneDataIndex($paneDataArray, paneId);\n\n  if (index < 0) return;\n  paneDataArray.update(curr => {\n    curr.splice(index, 1);\n    paneDataArrayChanged.set(true);\n    return curr;\n  });\n}\n\nfunction setupReactivePaneStyle(\n  el: HTMLElement,\n  groupData: PaneGroupData,\n  paneData: PaneData,\n  defaultSize: number | undefined\n) {\n  const getPaneStyle = () => {\n    const paneIndex = findPaneDataIndex(\n      groupData.paneDataArray.get(),\n      paneData.id\n    );\n    return computePaneFlexBoxStyle({\n      defaultSize,\n      dragState: dragState.get(),\n      layout: groupData.layout.get(),\n      paneData: groupData.paneDataArray.get(),\n      paneIndex\n    });\n  };\n\n  const arrUnsub = groupData.paneDataArray.subscribe(\n    _ => (el.style.cssText = getPaneStyle())\n  );\n  const layoutUnsub = groupData.layout.subscribe(_ => {\n    el.style.cssText = getPaneStyle();\n  });\n  const dragStateUnsub = dragState.subscribe(\n    _ => (el.style.cssText = getPaneStyle())\n  );\n\n  return [arrUnsub, layoutUnsub, dragStateUnsub];\n}\n\nfunction collapsePane(paneData: PaneData, groupData: PaneGroupData) {\n  const prevLayout = groupData.layout.get();\n  const paneDataArray = groupData.paneDataArray.get();\n\n  if (!paneData.constraints.collapsible) return;\n\n  const paneConstraintsArray = paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  const {\n    collapsedSize = 0,\n    paneSize,\n    pivotIndices\n  } = paneDataHelper(paneDataArray, paneData, prevLayout);\n\n  assert(paneSize != null);\n\n  if (paneSize === collapsedSize) return;\n\n  // Store the size before collapse, which is returned when `expand()` is called\n  groupData.paneSizeBeforeCollapseMap.update(curr => {\n    curr.set(paneData.id, paneSize);\n    return curr;\n  });\n\n  const isLastPane =\n    findPaneDataIndex(paneDataArray, paneData.id) === paneDataArray.length - 1;\n  const delta = isLastPane\n    ? paneSize - collapsedSize\n    : collapsedSize - paneSize;\n\n  const nextLayout = adjustLayoutByDelta({\n    delta,\n    layout: prevLayout,\n    paneConstraintsArray,\n    pivotIndices,\n    trigger: 'imperative-api'\n  });\n\n  if (areArraysEqual(prevLayout, nextLayout)) {\n    return;\n  }\n\n  groupData.layout.set(nextLayout);\n}\n\nfunction expandPane(paneData: PaneData, groupData: PaneGroupData) {\n  const prevLayout = groupData.layout.get();\n  const paneDataArray = groupData.paneDataArray.get();\n\n  if (!paneData.constraints.collapsible) return;\n  const paneConstraintsArray = paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  const {\n    collapsedSize = 0,\n    paneSize,\n    minSize = 0,\n    pivotIndices\n  } = paneDataHelper(paneDataArray, paneData, prevLayout);\n\n  if (paneSize !== collapsedSize) return;\n  // Restore this pane to the size it was before it was collapsed, if possible.\n  const prevPaneSize = groupData.paneSizeBeforeCollapseMap\n    .get()\n    .get(paneData.id);\n  const baseSize =\n    prevPaneSize != null && prevPaneSize >= minSize ? prevPaneSize : minSize;\n\n  const isLastPane =\n    findPaneDataIndex(paneDataArray, paneData.id) === paneDataArray.length - 1;\n\n  const delta = isLastPane ? paneSize - baseSize : baseSize - paneSize;\n\n  const nextLayout = adjustLayoutByDelta({\n    delta,\n    layout: prevLayout,\n    paneConstraintsArray,\n    pivotIndices,\n    trigger: 'imperative-api'\n  });\n\n  if (areArraysEqual(prevLayout, nextLayout)) return;\n\n  groupData.layout.set(nextLayout);\n}\n\nfunction handleTransition(\n  element: HTMLElement,\n  paneDataArray: Writable<PaneData[]>,\n  layout: Writable<number[]>,\n  pane: PaneData,\n  transState: PaneState\n) {\n  pane.state.set(transState);\n  tick().then(() => {\n    const computedStyle = getComputedStyle(element);\n\n    const hasTransition = computedStyle.transitionDuration !== '0s';\n\n    if (!hasTransition) {\n      const newState = isPaneCollapsed(paneDataArray.get(), layout.get(), pane)\n        ? PaneState.Collapsed\n        : PaneState.Expanded;\n      pane.state.set(newState);\n      return;\n    }\n    const handleTransitionEnd = (event: TransitionEvent) => {\n      // Only handle width/flex transitions\n      if (event.propertyName === 'flex-grow') {\n        pane.state.set(\n          isPaneCollapsed(paneDataArray.get(), layout.get(), pane)\n            ? PaneState.Collapsed\n            : PaneState.Expanded\n        );\n        element.removeEventListener('transitionend', handleTransitionEnd);\n      }\n    };\n\n    // Always add the listener - if there's no transition, it won't fire\n    element.addEventListener('transitionend', handleTransitionEnd);\n  });\n}\n", "/**\n * A callback function that takes an array of arguments of type `T` and returns `void`.\n * @template T The types of the arguments that the callback function takes.\n */\nexport type Callback<T extends unknown[] = unknown[]> = (...args: T) => void;\n\ntype NonEmptyArray<T> = [T, ...T[]];\n\n/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function chain<T extends unknown[]>(\n  ...callbacks: NonEmptyArray<Callback<T>>\n): (...args: T) => void {\n  return (...args) => {\n    for (const callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\n", "export type GeneralEventListener<E = Event> = (evt: E) => unknown;\n\nexport function addEventListener<E extends keyof HTMLElementEventMap>(\n  target: Window,\n  event: E,\n  handler: (this: Window, ev: HTMLElementEventMap[E]) => unknown,\n  options?: boolean | AddEventListenerOptions\n): VoidFunction;\n\nexport function addEventListener<E extends keyof HTMLElementEventMap>(\n  target: Document,\n  event: E,\n  handler: (this: Document, ev: HTMLElementEventMap[E]) => unknown,\n  options?: boolean | AddEventListenerOptions\n): VoidFunction;\n\nexport function addEventListener<E extends keyof HTMLElementEventMap>(\n  target: EventTarget,\n  event: E,\n  handler: GeneralEventListener<HTMLElementEventMap[E]>,\n  options?: boolean | AddEventListenerOptions\n): VoidFunction;\n\n/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(\n  target: Window | Document | EventTarget,\n  event: string | string[],\n  handler: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions\n) {\n  const events = Array.isArray(event) ? event : [event];\n\n  // Add the event listener to each specified event for the target element(s).\n  events.forEach(_event => target.addEventListener(_event, handler, options));\n\n  // Return a function that removes the event listener from the target element(s).\n  return () => {\n    events.forEach(_event =>\n      target.removeEventListener(_event, handler, options)\n    );\n  };\n}\n", "import { Hook } from 'phoenix_live_view';\nimport { dragState, paneGroupInstances, resizerInstances } from '../core';\nimport type {\n  Direction,\n  DragState,\n  GroupId,\n  PaneGroupData,\n  ResizeEvent,\n  ResizeHandler,\n  ResizerData,\n  ResizerId\n} from '../core';\nimport { chain } from '../chain';\nimport { addEventListener } from '../event';\nimport {\n  getCursorStyle,\n  resetGlobalCursorStyle,\n  setGlobalCursorStyle,\n  styleToString\n} from '../style';\nimport { Unsubscriber, writable, Writable } from '../store';\nimport { assert, isKeyDown, isMouseEvent, isTouchEvent } from '../utils';\nimport { areArraysEqual } from '../compare';\nimport { adjustLayoutByDelta } from '../adjust-layout';\n\nexport function createResizerHook() {\n  let resizerHook: Hook = {\n    mounted() {\n      // -- Retrieve data from group\n      let groupId = this.el.getAttribute('data-pane-group-id');\n      if (!groupId) {\n        throw Error('data-pane-group-id must exist for resizer components!');\n      }\n      let resizerId = this.el.getAttribute('id');\n      if (!resizerId) {\n        throw Error('Resizer id must exist for resizer components!');\n      }\n      const groupData = paneGroupInstances.get(groupId);\n      if (!groupData) {\n        throw Error(`Missing group \"${groupId} for resizer \"${resizerId}`);\n      }\n\n      // -- Register the resizer\n      const thisResizerData: ResizerData = {\n        disabled: writable(false),\n        isDragging: writable(false),\n        resizeHandlerCallback: null,\n        unsubs: [],\n        isFocused: writable(false)\n      };\n\n      resizerInstances.set(resizerId, thisResizerData);\n\n      // -- Prepare action params\n      thisResizerData.disabled.set(\n        this.el.getAttribute('data-pane-disabled') === 'true'\n      );\n\n      if (!thisResizerData.disabled.get()) {\n        const keyboardResizeBy = groupData.keyboardResizeBy;\n        thisResizerData.resizeHandlerCallback = (event: ResizeEvent) => {\n          const cursorPos = dragState.get()?.initialCursorPosition ?? null;\n          const initialLayout = dragState.get()?.initialLayout ?? null;\n          resizeHandler(\n            groupId,\n            resizerId,\n            groupData,\n            initialLayout,\n            cursorPos,\n            keyboardResizeBy,\n            event\n          );\n        };\n      }\n\n      const unsubEvents = setupResizeEvents(\n        resizerId,\n        this.el,\n        thisResizerData\n      );\n\n      thisResizerData.unsubs.push(unsubEvents);\n\n      // -- Set up the element\n      const style = styleToString({\n        cursor: getCursorStyle(groupData.direction.get()),\n        'touch-action': 'none',\n        'user-select': 'none',\n        '-webkit-user-select': 'none',\n        '-webkit-touch-callout': 'none'\n      });\n\n      this.el.style.cssText = style;\n\n      this.el.onblur = () => thisResizerData.isFocused.set(false);\n      this.el.onfocus = () => thisResizerData.isFocused.set(true);\n\n      this.el.onmousedown = e => {\n        e.preventDefault();\n        const nextDragState = startDragging(\n          groupData.direction,\n          groupData.layout,\n          resizerId,\n          e\n        );\n        dragState.set(nextDragState);\n        thisResizerData.isDragging.set(\n          dragState.get()?.dragHandleId === resizerId\n        );\n      };\n\n      this.el.onmouseup = () => {\n        dragState.set(null);\n        resetGlobalCursorStyle();\n        thisResizerData.isDragging.set(false);\n      };\n\n      this.el.ontouchcancel = () => {\n        dragState.set(null);\n        resetGlobalCursorStyle();\n        thisResizerData.isDragging.set(false);\n      };\n\n      this.el.ontouchend = () => {\n        dragState.set(null);\n        resetGlobalCursorStyle();\n        thisResizerData.isDragging.set(false);\n      };\n\n      this.el.ontouchstart = e => {\n        e.preventDefault();\n        const nextDragState = startDragging(\n          groupData.direction,\n          groupData.layout,\n          resizerId,\n          e\n        );\n        dragState.set(nextDragState);\n        thisResizerData.isDragging.set(\n          dragState.get()?.dragHandleId === resizerId\n        );\n      };\n\n      this.el.onkeydown = e => {\n        handleKeydown(\n          groupId,\n          resizerId,\n          thisResizerData.disabled.get(),\n          thisResizerData.resizeHandlerCallback,\n          e\n        );\n      };\n    },\n\n    destroyed() {\n      let resizerId = this.el.getAttribute('id');\n      for (const unsub of resizerInstances.get(resizerId!)?.unsubs ?? []) {\n        unsub();\n      }\n      resizerInstances.delete(resizerId!);\n    }\n  };\n\n  return resizerHook;\n}\n\nfunction setupResizeEvents(\n  resizerId: ResizerId,\n  node: HTMLElement,\n  params: ResizerData\n): Unsubscriber {\n  const { disabled, resizeHandlerCallback, isDragging } = params;\n\n  const onMove = (event: ResizeEvent) => {\n    if (\n      resizerId !== dragState.get()?.dragHandleId ||\n      disabled.get() ||\n      !isDragging.get() ||\n      resizeHandlerCallback === null\n    ) {\n      return;\n    }\n    resizeHandlerCallback(event);\n  };\n\n  const onMouseLeave = (event: ResizeEvent) => {\n    if (\n      resizerId !== dragState.get()?.dragHandleId ||\n      disabled.get() ||\n      !isDragging.get() ||\n      resizeHandlerCallback === null\n    ) {\n      return;\n    }\n    resizeHandlerCallback(event);\n  };\n\n  const stopDraggingAndBlur = () => {\n    if (resizerId !== dragState.get()?.dragHandleId) {\n      return;\n    }\n    node.blur();\n    isDragging.set(false);\n    dragState.set(null);\n    resetGlobalCursorStyle();\n  };\n\n  return chain(\n    addEventListener(document.body, 'contextmenu', stopDraggingAndBlur),\n    addEventListener(document.body, 'mousemove', onMove),\n    addEventListener(document.body, 'mouseleave', onMouseLeave),\n    addEventListener(window, 'mouseup', stopDraggingAndBlur),\n    addEventListener(document.body, 'touchmove', onMove, { passive: false }),\n    addEventListener(window, 'touchend', stopDraggingAndBlur)\n  );\n}\n\nfunction resizeHandler(\n  groupId: GroupId,\n  resizerId: ResizerId,\n  groupData: PaneGroupData,\n  initialLayout: number[] | null,\n  initialCursorPosition: number | null,\n  keyboardResizeBy: number | null,\n  event: ResizeEvent\n) {\n  event.preventDefault();\n\n  const direction = groupData.direction.get();\n  const $prevLayout = groupData.layout.get();\n  const $paneDataArray = groupData.paneDataArray.get();\n  const pivotIndices = getPivotIndices(groupId, resizerId);\n\n  let delta = getDeltaPercentage(\n    event,\n    resizerId,\n    direction,\n    initialCursorPosition,\n    keyboardResizeBy\n  );\n  if (delta === 0) return;\n\n  // support RTL\n  const isHorizontal = direction === 'horizontal';\n  if (document.dir === 'rtl' && isHorizontal) {\n    delta = -delta;\n  }\n\n  const paneConstraintsArray = $paneDataArray.map(\n    paneData => paneData.constraints\n  );\n\n  const nextLayout = adjustLayoutByDelta({\n    delta,\n    layout: initialLayout ?? $prevLayout,\n    paneConstraintsArray,\n    pivotIndices,\n    trigger: isKeyDown(event) ? 'keyboard' : 'mouse-or-touch'\n  });\n\n  const layoutChanged = !areArraysEqual($prevLayout, nextLayout);\n\n  if (isMouseEvent(event) || isTouchEvent(event)) {\n    // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n    // In this case, Pane sizes might not change\u2013\n    // but updating cursor in this scenario would cause a flicker.\n    const $prevDelta = groupData.prevDelta.get();\n\n    if ($prevDelta != delta) {\n      groupData.prevDelta.set(delta);\n\n      if (!layoutChanged) {\n        // If the pointer has moved too far to resize the pane any further,\n        // update the cursor style for a visual clue.\n        // This mimics VS Code behavior.\n        if (isHorizontal) {\n          setGlobalCursorStyle(delta < 0 ? 'horizontal-min' : 'horizontal-max');\n        } else {\n          setGlobalCursorStyle(delta < 0 ? 'vertical-min' : 'vertical-max');\n        }\n      } else {\n        setGlobalCursorStyle(isHorizontal ? 'horizontal' : 'vertical');\n      }\n    }\n  }\n\n  if (layoutChanged) {\n    groupData.layout.set(nextLayout);\n  }\n}\n\nfunction startDragging(\n  direction: Writable<Direction>,\n  layout: Writable<number[]>,\n  dragHandleId: string,\n  event: ResizeEvent\n) {\n  const handleElement = getResizeHandleElement(dragHandleId);\n  assert(handleElement);\n\n  return {\n    dragHandleId,\n    dragHandleRect: handleElement.getBoundingClientRect(),\n    initialCursorPosition: getResizeEventCursorPosition(direction.get(), event),\n    initialLayout: layout.get()\n  } satisfies DragState;\n}\n\n// -- Helper functions\nfunction getPivotIndices(\n  groupId: string,\n  dragHandleId: string\n): [indexBefore: number, indexAfter: number] {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getDeltaPercentage(\n  e: ResizeEvent,\n  dragHandleId: string,\n  dir: Direction,\n  initialCursorPosition: number | null,\n  keyboardResizeBy: number | null\n): number {\n  if (isKeyDown(e)) {\n    const isHorizontal = dir === 'horizontal';\n\n    let delta = 0;\n    if (e.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n    } else {\n      delta = 5;\n    }\n\n    let movement = 0;\n    switch (e.key) {\n      case 'ArrowDown':\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case 'ArrowLeft':\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case 'ArrowRight':\n        movement = isHorizontal ? delta : 0;\n        break;\n      case 'ArrowUp':\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case 'End':\n        movement = 100;\n        break;\n      case 'Home':\n        movement = -100;\n        break;\n    }\n\n    return movement;\n  } else {\n    if (initialCursorPosition == null) return 0;\n\n    const isHorizontal = dir === 'horizontal';\n\n    const handleElement = getResizeHandleElement(dragHandleId);\n    assert(handleElement);\n\n    const groupId = handleElement.getAttribute('data-pane-group-id');\n    assert(groupId);\n\n    const cursorPosition = getResizeEventCursorPosition(dir, e);\n\n    const groupElement = getPaneGroupElement(groupId);\n    assert(groupElement);\n\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = (offsetPixels / groupSizeInPixels) * 100;\n\n    return offsetPercentage;\n  }\n}\n\nfunction getResizeEventCursorPosition(dir: Direction, e: ResizeEvent): number {\n  const isHorizontal = dir === 'horizontal';\n\n  if (isMouseEvent(e)) {\n    return isHorizontal ? e.clientX : e.clientY;\n  } else if (isTouchEvent(e)) {\n    const firstTouch = e.touches[0];\n    assert(firstTouch);\n    return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    throw Error(\n      `Unsupported event type \"${(e as { type?: string }).type ?? 'unknown'}\"`\n    );\n  }\n}\n\nfunction getResizeHandleElementsForGroup(groupId: string): HTMLElement[] {\n  return Array.from(\n    document.querySelectorAll(\n      `[data-pane-resizer-id][data-pane-group-id=\"${groupId}\"]`\n    )\n  );\n}\n\nfunction getResizeHandleElementIndex(\n  groupId: string,\n  id: string\n): number | null {\n  const handles = getResizeHandleElementsForGroup(groupId);\n  const index = handles.findIndex(\n    handle => handle.getAttribute('data-pane-resizer-id') === id\n  );\n  return index ?? null;\n}\n\nfunction getResizeHandleElement(id: string): HTMLElement | null {\n  const element = document.querySelector(\n    `[data-pane-resizer][data-pane-resizer-id=\"${id}\"]`\n  );\n  if (element) {\n    return element as HTMLElement;\n  }\n  return null;\n}\n\nfunction getPaneGroupElement(id: string): HTMLElement | null {\n  const element = document.querySelector(\n    `[data-pane-group][data-pane-group-id=\"${id}\"]`\n  );\n  if (element) {\n    return element as HTMLElement;\n  }\n  return null;\n}\n\nfunction handleKeydown(\n  groupId: GroupId,\n  resizeHandleId: ResizerId,\n  disabled: boolean,\n  resizeHandler: ResizeHandler | null,\n  event: KeyboardEvent\n) {\n  if (disabled || !resizeHandler || event.defaultPrevented) return;\n\n  const resizeKeys = [\n    'ArrowDown',\n    'ArrowLeft',\n    'ArrowRight',\n    'ArrowUp',\n    'End',\n    'Home'\n  ];\n\n  if (resizeKeys.includes(event.key)) {\n    event.preventDefault();\n    resizeHandler(event);\n    return;\n  }\n\n  if (event.key !== 'F6') return;\n\n  event.preventDefault();\n\n  const handles = getResizeHandleElementsForGroup(groupId);\n  const index = getResizeHandleElementIndex(groupId, resizeHandleId);\n\n  if (index === null) return;\n\n  const nextIndex = event.shiftKey\n    ? index > 0\n      ? index - 1\n      : handles.length - 1\n    : index + 1 < handles.length\n      ? index + 1\n      : 0;\n\n  const nextHandle = handles[nextIndex] as HTMLElement;\n  nextHandle.focus();\n}\n", "import type { Hook } from 'phoenix_live_view';\nimport { createGroupHook } from './hooks/group';\nimport { createPaneHook } from './hooks/pane';\nimport { createResizerHook } from './hooks/resizer';\n\nexport function createLivePaneHooks() {\n  let groupHook: Hook = createGroupHook();\n  let paneHook: Hook = createPaneHook();\n  let resizerHook: Hook = createResizerHook();\n\n  return { groupHook, paneHook, resizerHook };\n}\n"],
  "mappings": "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",
  "names": ["paneData", "layout", "dragState", "paneConstraints", "delta", "pivotIndex", "prevSize", "unsafeSize", "safeSize", "paneData", "getResizeHandleElementsForGroup", "resizeHandler"]
}
